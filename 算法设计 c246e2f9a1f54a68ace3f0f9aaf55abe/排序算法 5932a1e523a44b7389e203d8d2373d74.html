<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>排序算法</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
	margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(50, 48, 44, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(50, 48, 44, 1);
}
.highlight-gray_background {
	background: rgba(248, 248, 247, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(248, 243, 252, 1);
}
.highlight-pink_background {
	background: rgba(252, 241, 246, 1);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(248, 248, 247, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(248, 243, 252, 1);
}
.block-color-pink_background {
	background: rgba(252, 241, 246, 1);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: undefined; }
.select-value-color-pink { background-color: rgba(225, 136, 179, 0.27); }
.select-value-color-purple { background-color: rgba(168, 129, 197, 0.27); }
.select-value-color-green { background-color: rgba(123, 183, 129, 0.27); }
.select-value-color-gray { background-color: rgba(84, 72, 49, 0.15); }
.select-value-color-transparentGray { background-color: undefined; }
.select-value-color-translucentGray { background-color: undefined; }
.select-value-color-orange { background-color: rgba(224, 124, 57, 0.27); }
.select-value-color-brown { background-color: rgba(210, 162, 141, 0.35); }
.select-value-color-red { background-color: rgba(244, 171, 159, 0.4); }
.select-value-color-yellow { background-color: rgba(236, 191, 66, 0.39); }
.select-value-color-blue { background-color: rgba(93, 165, 206, 0.27); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="5932a1e5-23a4-4b73-89e2-03d8d2373d74" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/circle-three-eighths_gray.svg"/></div><h1 class="page-title">排序算法</h1><p class="page-description"></p></header><div class="page-body"><h1 id="602b5f97-cd2a-4aa8-9f21-9d639b53bc55" class="">一、总览</h1><p id="6515e651-df68-40ef-8109-bf13bffe2f73" class="">可以根据该表格来选择对应合适的算法：<div class="indented"><figure id="1547c462-19a2-4412-af5d-f90046f24f9e" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled.png"><img style="width:432px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled.png"/></a></figure></div></p><p id="40f5a4a6-7510-438e-8086-cab9c98e3a5e" class="">并且关于该表格，还有一个记忆口诀<mark class="highlight-red">“有一只插帽龟它很稳。它喜欢选帽插，插完它就慌了”</mark></p><p id="7d45c6a6-184a-45c7-b3fe-ee8daa156f14" class="">该口诀的意义是：<div class="indented"><p id="5c93b16b-1053-4ab0-84d8-8edc15d0a99c" class="">插入、冒泡、归并排序是稳定的</p><p id="0ef43557-6e82-496f-84d1-40695b97db14" class="">选择、冒泡、插入的平均时间复杂度是O(<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span>)</p><blockquote id="13256489-4311-4fea-99d8-8722d3187acf" class="">“慌了”意同“方了”</blockquote></div></p><p id="2459eb9a-37d3-4a50-949d-5ba2f7771bbb" class="">还有一句口诀是<mark class="highlight-red">“n老快归队！”</mark></p><p id="5608a755-58f6-40eb-a2af-66eecaf89c14" class="">该口诀的意义是：<div class="indented"><p id="ac6ef59f-7f24-469a-9fed-83eae8b9ca3a" class="">快速、归并、堆排序的平均时间复杂度是<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span><span>﻿</span></span></p></div></p><h1 id="50230600-33ed-4e08-84df-85b991f3c6af" class="block-color-teal_background">二、插入排序</h1><h3 id="9e28b8bd-b725-495c-92f6-1cb3501d1dfe" class="">1-直接插入排序</h3><p id="46296006-f9ce-4103-8b1e-9e4b2e8ede90" class="">【定义】</p><p id="42fcb57d-904a-4336-ab1c-31e8e6d20631" class=""><mark class="highlight-blue">和前面的比，找到对应位置插入</mark></p><p id="82091f9c-ddca-4fb8-b4e6-f7d726eb2c78" class="">【示例】</p><ul id="92781f13-d0d8-451e-90f8-86873703edf9" class="toggle"><li><details open=""><summary>示例如下</summary><figure id="97d76210-a2d8-4ddc-b428-05ad307dc924" class="image" style="text-align:left"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/849589-20171015225645277-1151100000.gif"><img style="width:336px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/849589-20171015225645277-1151100000.gif"/></a></figure></details></li></ul><p id="3a44ca33-0fb6-4727-bf0e-c658f8bcf360" class="">【编程实现】</p><ul id="d6a906d8-23de-4733-af51-c17d178ece9c" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="de12ac40-a384-4f45-a5b0-876566a0c0ac" class="code"><code class="language-PHP">function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}</code></pre></details></li></ul><h3 id="6a3b22dd-46cf-43a8-9c48-909153e720d0" class="">2-希尔排序（shell排序）</h3><p id="08c2794a-2e1f-4b51-8868-734a05fdaf1b" class="">【定义】</p><p id="147e4404-b1d7-469a-ad7b-583f995d5ea5" class="">在直接插入排序的基础上进行的改进：将整个表分为多个子表，然后对每一个子表做直接插入排序</p><p id="3ae375ba-5eed-428c-8031-9ad9c02db7cc" class="">这种分割序列的方式能够在一定程度上减少插入排序中的元素移动次数，从而提高排序效率。</p><blockquote id="8268b8d1-657e-4026-a405-1c85c5594f5b" class="">因为直接做插入排序，当想要把一个很后面的元素插到一个很前面的元素之后时，那个很前面的元素的前面一大堆元素都要被后移，导致元素移动次数很多</blockquote><p id="181b9538-e74e-4ee0-9bdb-b2836774aa10" class="">【操作】</p><p id="2c509fcb-12ff-4ecd-9dec-aa5f5e0d85fd" class="">1、划分子表<div class="indented"><p id="799387ce-5ac0-41a0-aca5-b555ff2ec229" class="">我们一般会直接定义一个<mark class="highlight-blue">“步长”d=4</mark>，然后根据步长将表分为4个子表，如下：</p><figure id="2e0da5c2-8373-4384-bda3-4424df54c071" class="image" style="text-align:left"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%201.png"><img style="width:336px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%201.png"/></a></figure></div></p><p id="be34da3d-3d2c-47b9-86ed-b12151a7a04e" class="">2、<mark class="highlight-blue">对每一个子表做直接插入排序</mark><div class="indented"><ul id="edc2709b-0629-4fe6-8d71-23c07fd4d36d" class="toggle"><li><details open=""><summary>在前面的例子中，结果如下</summary><figure id="55f49e7c-f0d0-418f-9a79-e0699a79779e" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%202.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%202.png"/></a></figure></details></li></ul></div></p><p id="e546ce55-3451-4c44-a1a9-9be566be42df" class="">3、步长改成<mark class="highlight-blue">d=2</mark>，然后再分成2个子表，做直接插入排序<div class="indented"><ul id="b843adf6-eaeb-4f3e-b294-d6d97a6fcff6" class="toggle"><li><details open=""><summary>前面例子中如下</summary><figure id="97505ef5-e649-4b99-9735-446814c750a1" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%203.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%203.png"/></a></figure><p id="43ee25b3-2bb7-4a32-927e-67d6b119771b" class="">排序结果为：</p><figure id="8a4d49a4-4643-475e-ba59-a1ac5aa587c8" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%204.png"><img style="width:279px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%204.png"/></a></figure></details></li></ul></div></p><p id="eb7ccd10-d362-4c7e-954d-7ae218f3addb" class="">4、步长改成<mark class="highlight-blue">d=1</mark>，这样就只有他自己一个子表了，此时再做直接插入排序<div class="indented"><ul id="23abb669-a293-43f5-9f4a-3f87fa189316" class="toggle"><li><details open=""><summary>前面例子中如下</summary><figure id="3c295cc5-05e7-4280-ac82-8f510446daf3" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%205.png"><img style="width:336px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%205.png"/></a></figure></details></li></ul></div></p><blockquote id="62dd5e07-2c09-4594-bc0e-9331c57f1dca" class="">每次的d都是之前的一半</blockquote><p id="b9bfebe0-8257-4056-b35a-c3e123033cc5" class="">【编程实现】</p><ul id="fda8ff4b-8125-47b4-ae98-882568d25f4f" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d7b5c0af-44de-460f-a138-bb7ce5e216b4" class="code"><code class="language-PHP">function shellSort(arr) {
    var len = arr.length;
    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) {
        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
        for (var i = gap; i &lt; len; i++) {
            var j = i;
            var current = arr[i];
            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) {
                 arr[j] = arr[j - gap];
                 j = j - gap;
            }
            arr[j] = current;
        }
    }
    return arr;
}</code></pre></details></li></ul><h1 id="c21bc723-52b4-4b9b-a247-69c35abce997" class="block-color-teal_background">三、选择排序</h1><h3 id="efdad6bc-e781-4956-a2bc-a33f654250fd" class="">1-简单选择排序</h3><p id="013b3084-8dba-4699-969e-df932e5e44ea" class="">【定义】</p><p id="95332709-0c36-4d45-9cad-953564a0348c" class=""><mark class="highlight-blue">找到最小的元素后，和第一个元素交换</mark></p><p id="bb4d65f9-7abf-44b3-bcf0-7b455d47e43e" class="">【编程实现】</p><ul id="1b2a767f-5e3c-439f-9872-ff9d57c7ab8e" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6c46aeec-72d1-4257-8f65-60b2113a7bdd" class="code"><code class="language-PHP">function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} </code></pre></details></li></ul><h3 id="40fafb97-eb88-4d4c-b84c-608e8a32f5a9" class="">2-堆排序</h3><p id="38e11efe-36d9-4b72-a883-94dfe24d5a6d" class="">【定义】</p><p id="4f9788ec-01c9-40c9-9a78-75916d409244" class="">这里的堆指“二叉堆”，它分为以下两种：<div class="indented"><p id="27ec42b4-5d7f-4a41-9140-de54b3cb7631" class="">每个节点的值都大于或等于其子节点的值，为“最大堆”；反之为“最小堆”</p><figure id="3e183609-f3bf-4351-87f1-f924780c952f" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%206.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%206.png"/></a></figure><blockquote id="826dde85-f3fb-41cb-bea9-3b6adc56e0ca" class="">这里我们介绍基于“最大堆”的堆排序算法</blockquote></div></p><p id="2ba9dfbc-3b77-48b3-a068-38b4229ca3bd" class="">【操作】</p><blockquote id="1fa4f8a0-69a4-420b-b761-ab92a5d753ed" class="">以对这个序列进行堆排序为例：<figure id="1417412a-01f2-449b-8781-571f6cb677d7" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%207.png"><img style="width:384px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%207.png"/></a></figure></blockquote><p id="45438781-b186-43e3-a6c6-f59fffb5d260" class="">1、首先我们将数组我们将数组从上至下按顺序排列，转换成二叉树：一个无序堆<div class="indented"><figure id="cb0dbe39-f0e1-4144-b2e1-ee3f8682d525" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%208.png"><img style="width:192px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%208.png"/></a></figure></div></p><p id="ef71b5a3-3bb9-43b6-a532-adf87996200f" class="">2、按自下而上的顺序，对这个二叉树里面每一个三元子树转换成“每个节点的值都大于或等于其子节点的值”，如下：<div class="indented"><figure id="b4afa22c-33e7-4142-9981-d1fcb434291a" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%209.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%209.png"/></a></figure><ul id="b6ed31bb-586d-4402-afbe-02a9f2f2ae61" class="toggle"><li><details open=""><summary>交换结果如下</summary><figure id="efc4fb9b-8a4e-47b1-a3bc-9c8ac120c319" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2010.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2010.png"/></a></figure></details></li></ul></div></p><p id="e3e66ece-3808-4488-832a-f3522156c88d" class="">3、然后把堆顶元素（11）和最底部的元素（7）做交换，然后把<mark class="highlight-blue">被换下去的堆顶元素们标记为“有序区”</mark>，有序区之外的为“无序区”，只对无序区进行排序<div class="indented"><figure id="239cf29d-39be-4e0a-b05b-aba572c3ad66" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2011.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2011.png"/></a></figure><p id="f350c888-134d-4ebb-86dd-a6bd436840aa" class="">然后继续按自下而上的顺序排序每一个三元子树，排序完后结果加入“有序区”，以此不断扩大有序区，直到全部有序：</p><figure id="b8a33112-11ef-4621-8d4b-7445fb056828" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2012.png"><img style="width:192px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2012.png"/></a></figure></div></p><p id="a3067a37-4903-4ccc-acde-1a166e2f627f" class="">【编程实现】</p><ul id="548774eb-0079-42d6-9fbf-2d64600fbcdd" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="69a36b88-9b21-43b1-aa51-c42715261454" class="code"><code class="language-PHP">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}
 
function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }
 
    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }
 
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
function heapSort(arr) {
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}</code></pre></details></li></ul><h1 id="2dd77aa3-553a-4da7-a05f-09e182b61f7a" class="block-color-teal_background">四、交换排序</h1><h3 id="eb71588a-ddc4-4015-814d-6218c7571189" class="">1-冒泡排序</h3><p id="b9ff9c0f-e864-41a2-813a-762b9b7cdcf4" class="">【定义】</p><p id="47e3e22f-1a0f-46da-9b71-0a83e068d557" class="">对于有n个元素的数组，进行n-1次以下操作：<div class="indented"><p id="f5150c1e-7b80-4b25-ac51-2c3a7e08af9a" class="">将第一个元素一直<mark class="highlight-blue">往后面“冒泡”</mark>一直遇到比它大的元素，然后那个<mark class="highlight-blue">比它大的元素”接力“</mark>地继续往后面冒泡，一直接力<mark class="highlight-blue">冒泡到数组末端位置</mark>就是那个最大的元素</p></div></p><p id="8dfdeac2-f6bb-49e3-9afc-29b95f5b3422" class="">【示例】</p><ul id="bfb81ab2-a620-41af-8f94-6d41d7c5c51b" class="toggle"><li><details open=""><summary>示例如下</summary><figure id="cf9a34d0-0963-43ef-bf5a-4470c883ad03" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/849589-20171015223238449-2146169197.gif"><img style="width:384px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/849589-20171015223238449-2146169197.gif"/></a></figure><p id="f3b78a72-79e2-4772-8c86-faf933410b4f" class="">
</p></details></li></ul><p id="218b7c67-b84a-450b-acfe-811e834bb1dc" class="">【编程实现】</p><ul id="2065dd99-260e-4a61-bc47-38229ce9d55b" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5bd5cb81-ad5f-470e-a031-e6dd5d6c568f" class="code"><code class="language-PHP">function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}</code></pre></details></li></ul><h3 id="60d3c3fb-f852-4b8c-9830-b373bf41dca3" class="">2-快速排序</h3><p id="c782dc1b-143b-4694-979e-a517151eadbb" class="">【定义】</p><p id="5b0e9776-55ed-4a18-ab42-1d49b8b04dd4" class="">有一首描述其排序过程的打油诗：<div class="indented"><p id="a4501811-6ef7-4026-8061-b06165737413" class=""><mark class="highlight-blue">小放枢纽左，大放枢纽右</mark></p><p id="60d733c1-13d2-4da6-a9f1-431fd8e8db90" class=""><mark class="highlight-blue">高低所指换，换针向枢纽</mark></p><p id="8b7fd9a2-795d-43e8-a610-a6ffd1c9b477" class=""><mark class="highlight-blue">高低所遇处，枢轴所落入</mark></p><p id="37035bb5-2652-4765-82c5-20cfe0699aec" class=""><mark class="highlight-blue">递归再排至，左右仅一头</mark></p></div></p><p id="e9e62e9d-f6a2-474d-9d00-60d0a7300f2b" class="">【操作】</p><p id="40f7ac3c-a65e-4477-8e54-61221ded99e9" class="">这里是打油诗的详细解释：</p><p id="85b74d35-7876-4222-a976-434c02550893" class="">1、先把数组的<mark class="highlight-blue">第一个元素作为枢轴</mark>，如下：<div class="indented"><figure id="8522fba4-4144-453b-a5d0-451df29027c3" class="image" style="text-align:left"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2013.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2013.png"/></a></figure></div></p><p id="67a97cac-3ac1-4dc3-900e-a0a38badc190" class="">并且规定<mark class="highlight-blue">“枢轴左边的元素要比右边的元素小”</mark>，通过后续操作来实现这种规定</p><p id="df4cc643-491d-441c-9011-d7c084923676" class="">2、设置一个<mark class="highlight-blue">high和low指针</mark>，一开始是二者比较，如果low≤high，则将<mark class="highlight-blue">high向枢轴的方向移</mark>1格再做比较~</p><p id="ad7fbd75-3e50-4923-9e83-130f9db655d4" class="">如下<div class="indented"><p id="fa202416-44d4-4b75-a597-d1e6be08e137" class="">（1）49和49比一样大所以不换</p><figure id="f8acdcfa-7538-4643-ad41-dfe6f59d7260" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2014.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2014.png"/></a></figure><p id="3f990457-b04b-4416-8183-8caa5bdd2345" class="">（2）然后移动high向枢轴，再比较</p><figure id="d877e17a-48af-4743-9ca7-d9637a6b07d4" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2015.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2015.png"/></a></figure><p id="35e16974-76f0-41c6-b1ab-07235b4d3a00" class="">这里27&lt;49，所以<mark class="highlight-blue">二者值要交换</mark>以满足“枢轴左边的元素要比右边的元素小”，并且将<mark class="highlight-blue">枢轴的位置也要换</mark>到原来27的地方，并且“<mark class="highlight-blue">换针向枢轴</mark>”也就是改成让low去靠近枢轴</p><figure id="31cb0b5f-d486-427b-ae89-2d8a2de2f4fe" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2016.png"><img style="width:288px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2016.png"/></a></figure></div></p><ul id="7e215a52-125f-4d00-9fa3-b6691518b1c0" class="toggle"><li><details open=""><summary>然后就是重复这个过程，直到low和high指针相遇~，具体重复过程如下</summary><p id="3ca6f64e-3710-4b9b-8c5d-3dab72a46f73" class="">low++，38&lt;49，不动</p><figure id="e5ac861d-7eb4-46d5-8fb7-df926729f0d9" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2017.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2017.png"/></a></figure><p id="9a1ca85c-296f-474a-9281-c26b886135e0" class="">low++，65&gt;49，再次进行交换过程</p><figure id="787e54cd-624d-4f5b-bb85-2cb49def71fc" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2018.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2018.png"/></a></figure><p id="ba052a45-9f71-4679-b769-fa251abda21e" class="">移动high，49&gt;13，再进行交换过程</p><figure id="49bbfa46-cc5e-4d8a-95a8-156f2147b9a2" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2019.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2019.png"/></a></figure><p id="4003c60a-c8a4-4d77-a2af-29dbe819ed44" class="">移动low，97&gt;49，再进行交换过程</p><figure id="93820364-14b2-4f5a-8f9c-baf4c7f20e73" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2020.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2020.png"/></a></figure><p id="145fa9cf-2678-4ec9-a704-3a1b9a22ada0" class="">移动high，26&lt;49，再进行交换过程</p><figure id="c9391f92-74c9-4fee-b748-eefd7b9cda77" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2021.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2021.png"/></a></figure><p id="6d42c79a-4c7d-4132-8c16-68ff3e66270d" class="">然后移动low，相遇如下：</p><figure id="5c0c7139-4946-499b-a9c2-524b5e98d6a0" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2022.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2022.png"/></a></figure></details></li></ul><p id="1fbd8132-b8cd-4d56-baaf-81e88a7e75e2" class="">3、“高低所遇处，枢轴所落入”<div class="indented"><p id="4afebdb3-842a-43b9-8827-86b7c50da66c" class="">相遇后，把枢轴落入low、high所同时指向的那个格子里</p><figure id="1a1b2e06-3b35-4088-af91-5e3f29fecb55" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2023.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2023.png"/></a></figure><blockquote id="54f38b2f-eeb1-4ac3-b500-0628cf93c86e" class="">现在我们可以看到，此时确实比枢轴小的都在枢轴左边，比枢轴大的都在枢轴右边了</blockquote></div></p><p id="c3b9ceb9-8632-49bc-9533-4d6c5cc107c7" class="">4、此时再对枢轴左右的两个子数组分别进行快速排序过程……<div class="indented"><figure id="cd4b6ec6-0ae8-4f10-83c5-4cf490167c3b" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2024.png"><img style="width:240px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2024.png"/></a></figure><blockquote id="32caf4bb-6232-4ca0-94b2-3955a99421db" class="">一直到某个时候，枢纽的左右两个子数组都只有一个元素的时候就可以done~</blockquote></div></p><p id="bcd8fb59-00de-45a4-bb57-f3f4ffb783f4" class="">【编程实现】</p><ul id="cda410dc-0942-45a8-b003-046a58126b1a" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="55570eb9-7501-4a71-ab4b-fca79d073cd7" class="code"><code class="language-PHP">function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#x27;number&#x27; ? 0 : left,
        right = typeof right != &#x27;number&#x27; ? len - 1 : right;
 
    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
 
function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }       
    }
    swap(arr, pivot, index - 1);
    return index-1;
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}</code></pre></details></li></ul><h1 id="dc22fd0a-924a-44a3-b3ad-4cdbe268f1c2" class="block-color-teal_background">五、其他</h1><h3 id="40e1691a-27ba-46be-9795-a3db901454b8" class="">1-归并排序</h3><p id="db5712f9-a75b-4f42-9469-e0d96e9c22cf" class="">【定义】</p><p id="0219ac2e-81b5-4456-94bd-72c37d4e112f" class="">用分治思想，分治模式在每一层递归上有三个步骤：</p><ul id="8c10283e-0995-49f3-aacb-2c9a404cc386" class="bulleted-list"><li style="list-style-type:disc"><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li></ul><ul id="59ee8b39-2e6f-40e0-91fd-7759ebb6fe97" class="bulleted-list"><li style="list-style-type:disc"><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li></ul><ul id="b1e676e6-78ad-4e01-b839-06ce9b29e967" class="bulleted-list"><li style="list-style-type:disc"><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ul><p id="00580041-d1f7-427b-b11b-3564d07efd14" class="">思路简单，速度仅次于快速排序，但为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p id="243d67a6-fb74-40d4-b148-80ff17bd4874" class="">【操作】</p><p id="806a0e90-22e3-404a-a47c-098fe0d72f65" class="">其操作逻辑如下图所示：</p><figure id="4bf06fb1-19f0-4dc2-a7e3-03e9ed537a2d" class="image" style="text-align:left"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled.webp"><img style="width:336px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled.webp"/></a></figure><p id="008273f2-ee01-4b51-8527-f84d07fe2c13" class="">【编程实现】</p><ul id="50277449-3fed-471d-94eb-7e7391210d65" class="toggle"><li><details open=""><summary>代码如下</summary><p id="67944a9f-3bd5-4d09-8cd7-2089e33da5dd" class="">迭代法：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="519def30-5f71-484d-a1cd-f426da55b659" class="code"><code class="language-PHP">// 归并排序（C-迭代版）
int min(int x, int y) {
    return x &lt; y ? x : y;
}
void merge_sort(int arr[], int len) {
    int* a = arr;
    int* b = (int*) malloc(len * sizeof(int));
    int seg, start;
    for (seg = 1; seg &lt; len; seg += seg) {
        for (start = 0; start &lt; len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)
                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];
            while (start1 &lt; end1)
                b[k++] = a[start1++];
            while (start2 &lt; end2)
                b[k++] = a[start2++];
        }
        int* temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        int i;
        for (i = 0; i &lt; len; i++)
            b[i] = a[i];
        b = a;
    }
    free(b);
}</code></pre><p id="f4daa07d-5004-413c-a041-2289209be0d1" class="">递归法：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8915e83c-1df5-4c1a-84cc-92244da10088" class="code"><code class="language-PHP">// 归并排序（C-递归版）
void merge_sort_recursive(int arr[], int reg[], int start, int end) {
    if (start &gt;= end)
        return;
    int len = end - start, mid = (len &gt;&gt; 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
    int k = start;
    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 &lt;= end1)
        reg[k++] = arr[start1++];
    while (start2 &lt;= end2)
        reg[k++] = arr[start2++];
    for (k = start; k &lt;= end; k++)
        arr[k] = reg[k];
}
void merge_sort(int arr[], const int len) {
    int reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}</code></pre></details></li></ul><h3 id="926969c7-0611-4f45-899f-932b48cdb3d2" class="">2-基数排序</h3><p id="0fb44c92-0aaa-41c1-8c73-9f884823d4bf" class="">【定义】</p><p id="fbd715c0-60d4-4918-ae5b-94b3e176a474" class="">原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p id="47e9516c-75d7-4425-a9c6-f04d541fe9d8" class="">基数排序的方式可分为LSD（Least significant digital）或MSD（Most significant digital），其中：<div class="indented"><p id="acaf6d2a-bd1f-40a5-b5f2-5c46dd22e17f" class="">MSD：先从高位开始进行排序，在每个关键字上，可采用计数排序</p><p id="a9f513d4-c6ec-42ba-bc37-aa576519b245" class="">LSD：先从低位开始进行排序，在每个关键字上，可采用桶排序</p></div></p><p id="5c30339e-9a1b-48c0-a47c-ae0f70af8369" class="">【操作】</p><p id="99b9f78e-cfdf-4789-91bd-5581e215535f" class="">1、将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</p><p id="b17cd155-af1e-4e50-9916-b2394a19ff3b" class="">2、从<mark class="highlight-blue">最低位开始</mark>，依次进行一次排序。</p><p id="2b51e0de-3600-4ab6-bdfd-3111f88cee83" class="">3、这样从最低位排序<mark class="highlight-blue">一直到最高位排序完成</mark>以后, 数列就变成一个有序序列。</p><p id="b3a5975e-ea66-4b09-a764-927e1197ceba" class="">示例如下：</p><figure id="0c1bf9ff-c281-442d-b838-79729bec741f" class="image" style="text-align:left"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2025.png"><img style="width:432px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2025.png"/></a></figure><p id="0c816e17-0fea-4bbe-b7ab-fae837247e95" class="">【编程实现】</p><ul id="d6ec29c9-de38-4178-a5f9-345687054f8a" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1b8dafb4-1c5a-4acd-a5e5-5881283d351a" class="code"><code class="language-PHP">var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j &lt; arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}</code></pre></details></li></ul><h3 id="a8706c29-df85-4136-9cfa-e4dc4db25604" class="">2-其他之其他</h3><ul id="5ffc8060-ddbf-4e6d-8772-67a6b0637ea7" class="toggle"><li><details open=""><summary>计数排序</summary><p id="1a9d3856-b7f2-4e43-beeb-2788d2e2e722" class="">【编程实现】</p><ul id="d5d3c2e9-e79f-4cb5-80d7-49e9b3528d20" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7d84acce-399a-4b47-9ae4-6489c57756c1" class="code"><code class="language-PHP">function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue + 1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;
 
    for (var i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }
 
    for (var j = 0; j &lt; bucketLen; j++) {
        while(bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
 
    return arr;
}</code></pre></details></li></ul></details></li></ul><ul id="f39cc6f8-bfd8-418d-a220-a6fa95bd67ae" class="toggle"><li><details open=""><summary>桶排序</summary><p id="ba21b1ea-a578-432c-8ba0-157aa2f81d5f" class="">【编程实现】</p><ul id="af7fa019-fcd0-41b7-800b-71e10ec724b0" class="toggle"><li><details open=""><summary>代码如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cd290531-0c29-4778-b5cc-1c7be653f06f" class="code"><code class="language-PHP">function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }
 
    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i &lt; arr.length; i++) {
      if (arr[i] &lt; minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] &gt; maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }
 
    // 桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
    var buckets = new Array(bucketCount);
    for (i = 0; i &lt; buckets.length; i++) {
        buckets[i] = [];
    }
 
    // 利用映射函数将数据分配到各个桶中
    for (i = 0; i &lt; arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }
 
    arr.length = 0;
    for (i = 0; i &lt; buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j &lt; buckets[i].length; j++) {
            arr.push(buckets[i][j]);                     
        }
    }
 
    return arr;
}</code></pre></details></li></ul></details></li></ul><h1 id="7d9cb156-5ba8-4aa2-99d3-7f8681c38493" class="">六、练习</h1><ul id="7fbeb579-8c12-40ae-883a-2e07e383712e" class="toggle"><li><details open=""><summary>希尔排序</summary><p id="fe226a6f-2de5-4bf4-9612-2945e967737e" class=""><strong>题目：</strong></p><p id="3df63706-645a-4ffa-a530-a29c2dd2d214" class="">使用希尔排序法进行排序，若第一趟排序后排序结果为9，1，4，13，7，8，20，15，则该趟排序采用的增量（间隔）可能是（）。</p><p id="eabbf5ce-2fd2-4386-ae7f-70b0cc6fc3a0" class="">A.2</p><p id="0e5daad7-7754-499e-95dc-6bc2baa1b7e9" class="">B.3</p><p id="79a61233-1eb8-4fc1-b4af-b1f3d8d98ea5" class="">C.4</p><p id="707a7a4f-9c19-4630-9a52-9613417a8354" class="">D.5</p><p id="dfa8532a-c875-4225-b096-3c8ec682d87e" class=""><strong>解：</strong></p><p id="80d40009-99f9-483d-b177-f0d58e7d3e9f" class="">用排除法</p><p id="626ed112-69a3-4bb0-ab5e-7c46e9d061e8" class="">1、假设是增量为5，则排序后的5个组应该分别为：9,8；1,20；4,15；13；7；</p><p id="2f8719da-0e25-42f3-8f95-188a73ef9185" class="">可以看到9&gt;8所以这个肯定不是增量五</p><p id="bd33fba6-3e7a-4be4-8f19-4fcd0dbc3c85" class="">2、假设增量为4，则排序后的4个组应该分别为：9,7；1,8；4,20；13,15；</p><p id="09255cb0-7aca-4ae7-88f2-5898288dbb6d" class="">可以看到9&gt;7不是增量四</p><p id="56a37d71-f678-47ad-8607-c70672cbba93" class="">3、假设增量为3，则排序后的3个组应该分别为：9,13,20；1,7,15；4,8；</p><p id="5adb2c0b-4a6f-4f0d-9272-d1217bad8292" class="">可以看到这三个组都是顺序排序，所以应该是增量三！</p></details></li></ul><ul id="cc9ad10a-4710-457d-963d-2e0ed0bf2c70" class="toggle"><li><details open=""><summary>快速排序</summary><p id="08ed1073-c7f6-40f8-b206-a79374fc0678" class=""><strong>题目：</strong></p><p id="8d955bd3-5550-4419-8dde-bc9933d24935" class="">已知关键字集合：{50，52，85，22，96，17，36，55}，写出快速排序第一趟划分过程及每一趟划分结果。</p><p id="613ec4c2-d016-43f2-8aa4-b0ee2f25c4ab" class=""><strong>解：</strong></p><figure id="46e8dd48-e65b-4a23-9dc1-d0cc405e0ec3" class="image"><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2026.png"><img style="width:576px" src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%205932a1e523a44b7389e203d8d2373d74/Untitled%2026.png"/></a></figure></details></li></ul><p id="3310d853-1727-413a-a8ab-4b5b5b4d203a" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>