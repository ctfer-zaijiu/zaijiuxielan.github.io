<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>堆创建删除过程（附源码）</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
	margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(50, 48, 44, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(50, 48, 44, 1);
}
.highlight-gray_background {
	background: rgba(248, 248, 247, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(248, 243, 252, 1);
}
.highlight-pink_background {
	background: rgba(252, 241, 246, 1);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(248, 248, 247, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(248, 243, 252, 1);
}
.block-color-pink_background {
	background: rgba(252, 241, 246, 1);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: undefined; }
.select-value-color-pink { background-color: rgba(225, 136, 179, 0.27); }
.select-value-color-purple { background-color: rgba(168, 129, 197, 0.27); }
.select-value-color-green { background-color: rgba(123, 183, 129, 0.27); }
.select-value-color-gray { background-color: rgba(84, 72, 49, 0.15); }
.select-value-color-transparentGray { background-color: undefined; }
.select-value-color-translucentGray { background-color: undefined; }
.select-value-color-orange { background-color: rgba(224, 124, 57, 0.27); }
.select-value-color-brown { background-color: rgba(210, 162, 141, 0.35); }
.select-value-color-red { background-color: rgba(244, 171, 159, 0.4); }
.select-value-color-yellow { background-color: rgba(236, 191, 66, 0.39); }
.select-value-color-blue { background-color: rgba(93, 165, 206, 0.27); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="4577645d-fc3b-419b-9e61-5a0dc389f6fa" class="page sans"><header><img class="page-cover-image" src="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/firefox_oZt25cSg0n.png" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><img class="icon" src="https://www.notion.so/icons/condense_red.svg"/></div><h1 class="page-title">堆创建删除过程（附源码）</h1><p class="page-description"></p></header><div class="page-body"><blockquote id="e094cf59-4bfe-460d-87e4-8cc687016f22" class="block-color-gray">排云驭霞兮欲何之，浪蹄落花兮坠何之。</blockquote><h1 id="17d0427e-38bb-8050-a7c6-c359cf56812d" class="block-color-default_background">一、相关前置代码</h1><h3 id="17d0427e-38bb-80d1-9004-fc624c63faab" class="">1-通用前置代码</h3><ul id="17d0427e-38bb-800e-9456-c4755e148966" class="toggle"><li><details open=""><summary><strong>1、会用到的相关宏：chunk漫游、chunk标志位相关、其他</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17d0427e-38bb-807d-8508-ffe69d4b9f4a" class="code"><code class="language-Plain Text">//1、chunk漫游=======================
//1.1、前后漫游
//这里的next_chunk宏其实就是通过chunk地址加上该chunk大小从而得到下一个物理相邻chunk的地址。这个很重要！这里涉及到了漏洞利用！
#define next_chunk(p)        ((mchunkptr) (((char *) (p)) + chunksize(p)))
#define prev_chunk(p)        ((mchunkptr) (((char *) (p)) - (p)-&gt;prev_size))
//1.2、偏移漫游
//计算给定内存块 p 偏移量为 s 的位置，并返回该位置的地址值。
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
//1.3、块头&amp;块体漫游
//这里mem指向一个块的data部分，chuk指向一个块的块头部分，他们之间相差两个指针大小。
#define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))


//2、chunk标志位相关=================
//2.1、设置
//把当前chunk的prev_inuse标志位设置为0
#define clear_inuse_bit_at_offset(p, s)		 (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))
//设置当前chunk的size字段
#define set_head(p, s)       ((p)-&gt;size = (s))
//设置当前chunk的下一个chunk的prev_size字段（只当freechunk时这么设置！）
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))
//2.2、检查
//查看当前chunk的物理相邻上一个chunk是否正在使用，原理是通过直接查看当前chunk的P位是否==1
#define prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)
//查看当前chunk是否为inuse，原理是通过查看它物理相邻的下一个chunk的PREV_INUSE位
#define inuse(p)							      \
  ((((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)
//检查当前chunk的大小是否小于largebin的最小大小
#define in_smallbin_range(sz)   ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)
//2.3、查看
#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))

//3、内存初始化=============================
//在malloc时，用perturb_byte^0xff来初始化填充块内容。（这里^0xff就相当于是把perturb_byte的全部位取反，这是为了调试时可以更容易地识别出是在使用未初始化的内存还是在使用已经释放的内存）
//在free时，用perturb_byte来初始化填充块内容。
//注意，perturb_byte 的默认值通常是 0，而当perturb_byte==0时，默认不进行内存扰动操作！！！（以减少时间消耗）只有当调试时设置了perturb_byte，才会进行内存扰动操作。
static void alloc_perturb (char *p, size_t n){
  if (__glibc_unlikely (perturb_byte))
    memset (p, perturb_byte ^ 0xff, n);
}
static void free_perturb (char *p, size_t n){
  if (__glibc_unlikely (perturb_byte))
    memset (p, perturb_byte, n);
}

//4、其他=====================================
//最小chunk大小=4个指针大小
#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</code></pre></details></li></ul><ul id="17d0427e-38bb-80e3-abf3-ccafb6e14bb8" class="toggle"><li><details open=""><summary><strong>2、会用到的一些检查函数：do_check_chunk函数</strong></summary><p id="63126137-109e-4b27-86e3-44a38d40f351" class="">【流程简介】</p><p id="5ff24e4e-89c1-42fa-a5bc-7a83bbf06f0a" class="">1、对于普通块，分析当前块头、尾所处位置的合法性</p><p id="b4abf5e2-a7a5-4d6a-8ae5-60afec5c8e3e" class="">2、对于topchunk，检查其大小是否合法，以及检查其前一个块是否遵守“总是标记为已使用”</p><blockquote id="aa6bddb9-b48b-485d-8de1-3973d1f3efea" class="">在哪里都可以看到这小子，一般在任何check函数的开头都会调用该函数check一下~真偷懒啊开发者</blockquote><p id="17d0427e-38bb-800c-8e83-d50673b10101" class="">【代码】</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="38eda44f-c651-4bba-98b0-db1a92d8a59e" class="code"><code class="language-Plain Text">//其中，do_check_chunk函数定义如下：------------------------------------------
static void do_check_chunk (mstate av, mchunkptr p){
  // 获取块的大小
  unsigned long sz = chunksize (p);
  // 0、假设连续分配下，计算p的地址可合法取得的最小值和最大值
  char *max_address = (char *) (av-&gt;top) + chunksize (av-&gt;top);
  char *min_address = max_address - av-&gt;system_mem;

  // 如果块不是通过 mmap 分配的
  if (!chunk_is_mmapped (p)){
			// 如果当前块不是topchunk
      if (p != av-&gt;top){
          // 如果当前堆区是连续的
          if (contiguous (av)){
              // 1、检查块地址在最小和最大地址之间
              // 这是为了防止“fastbin的任意分配漏洞”之类的，在任意地址上面构建freechunk的漏洞
              assert (((char *) p) &gt;= min_address);              //当前块头地址必须是大于刚刚算出来的可合法取得的最小值
              assert (((char *) p + sz) &lt;= ((char *) (av-&gt;top)));//通过块头+块的大小，计算当前块尾地址要求其不超过topchunk头地址
            }
        }
      // 如果当前块是topchunk
      else{
          // 2、检查：
          //   （1）top 块的大小至少为 MINSIZE
          //   （2）top 块的前一个块是否遵守“总是标记为已使用”
          assert ((unsigned long) (sz) &gt;= MINSIZE);
          assert (prev_inuse (p));//因为正常来说，topchunk会因为合并机制而去吞并它之前的所有freechunk直到遇到一个inuse的chunk
													        //如果没有这样的话，那或许说明topchunk的位置被人为修改过！
        }
    }
  // 如果块是通过 mmap 分配的，即：块的地址在主堆外
  else{
		  // 如果当前这个堆地址是连续的，但它的topchunk不是主堆的那个topchunk
      if (contiguous (av) &amp;&amp; av-&gt;top != initial_top (av)){
          // 3、检查：当前块起始地址必须在最小地址之前或最大地址之间，否则报错
          assert (((char *) p) &lt; min_address || ((char *) p) &gt;= max_address);
        }
      // 4、进行以下两个检查：
      //   （1）块大小与前一个块的大小之和是否按照系统内存页大小对齐。
      //   （2）检查给定块 p 的起点地址是否按照系统要求向4B&amp;8B对齐。
      assert (((p-&gt;prev_size + sz) &amp; (GLRO (dl_pagesize) - 1)) == 0);
      assert (aligned_OK (chunk2mem (p)));
    }
}</code></pre></details></li></ul><h3 id="17d0427e-38bb-8006-bd57-d4b5d86f1de0" class="">2-malloc专用前置代码</h3><ul id="7cd63176-484b-4433-83fe-879fe236724f" class="toggle"><li><details open=""><summary><strong>1、会用到的相关宏：标记位设置、bin链表维护、位图、size检查和转换</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="46c83d57-1cac-4a69-86e8-8cf98217d959" class="code"><code class="language-Plain Text">//1、一些标记位设置相关宏：
#define set_head(p, s)       ((p)-&gt;size = (s))
//可以看到所谓的对一个chunk的“setfoot”操作，实际上就是在其末4B（x64下是末8B）写入它的size，也就相当于是在填写它的物理相邻下一个chunk的prev_size
//因为prevsize只用于freechunk，所以只有被free的chunk或者被切割后剩下的remainder会需要被进行set_foot操作！
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))

//2、一些bin链表维护的宏：
//2.1、first、last：获得链表头或者链表尾
#define first(b)     ((b)-&gt;fd)
#define last(b)      ((b)-&gt;bk)
//2.2、bin_at：返回指定索引对应的bin的指针（也就是说，返回的是bins[idx]这个数组元素的地址）
#define bin_at(m, i) \
  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))
  
//3、位图相关：
#define NBINS            128
#define BINMAPSHIFT      5
#define BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)             // 1U &lt;&lt; 5 相当于 1 * 2^5 = 32
#define BINMAPSIZE       (NBINS / BITSPERMAP)            // 128 / 32 相当于 4
#define idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)            // idx &gt;&gt; 5 ，因为largebin是位于bin[64]~bin[126]，也就是说其idx是0b100,0000~0b111,1110，&gt;&gt;5就必得到0b10也就是2。该字段是用来做binmap的下标，也就是说largebin对应的就是binmap[2]。
#define idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))     // (1U &lt;&lt; BINMAPSHIFT) - 1得0b11111，去&amp;idx也就相当于只保留末5个二进制位，也就是——获取i的最低BINMAPSHIFT个位（5位），这实际上是i在block内的偏移量。
                                                                         // 最后将1左移上述计算出的偏移量。它生成了一个仅有一个位被设置为1的数，这个1的位置正好对应于bin索引i在位图的某个unsigned int中的位置。
                                                                         // 把位图的那个unsigned int，去 &amp; “这个idx2bit(idx)的结果”，得到的值如果非0就表示idx对应的largebin不为空，否则则为空。
unsigned int binmap[BINMAPSIZE];                         // 一共5个unsigned int，每个是32位。largebin对应的是binmap[2]，这个unsigned int的32个bit对应的是32条largebin是否为空。

//4、chunk切割相关宏
//chunk_at_offset：输入victim位置和所需切割的大小，输出切割后remainder块头的地址。
//由此可以看出，切割后的victim在低地址，切割后的remainder在高地址。
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))

//5、size检查和转换
//最小chunk大小
//其中，MIN_CHUNK_SIZE表示malloc_chunk结构体从开始处到 fd_nextsize 成员开始之间的字节数，是4*SIZE_SZ；这个MINSIZE的值也一般是4*SIZE_SZ
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
#define MINSIZE  \
  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
//x32下MALLOC_ALIGNMENT=8,MALLOC_ALIGN_MASK=7
#define MALLOC_ALIGNMENT       MAX (2 * sizeof(size_t),__alignof__ (long double))
#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)
//checked_request2size：检查请求的大小是否是一个合理的范围，将请求的大小转换为_int_malloc中实际要申请的块大小。
#define checked_request2size(req, sz)                             \
  if (REQUEST_OUT_OF_RANGE (req)) {					      \
      __set_errno (ENOMEM);						      \
      return 0;								      \
    }									      \
  (sz) = request2size (req);
//其中，涉及到的宏定义有两个：
//（1）REQUEST_OUT_OF_RANGE：检查要申请的大小是否过大！
//    看要申请的大小是否大于(unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))，如果大于就算溢出了，返回true。
//    这里(-2 * MINSIZE)它实际上是0xFFFF FFFF FFFF FFF0。被转换成无符号数是一个特别大的数。
#define REQUEST_OUT_OF_RANGE(req)                                 \
  ((unsigned long) (req) &gt;=						      \
   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))
// （2）request2size：把用户申请的大小，转换为_int_malloc中实际要申请的块大小。
//    用户程序要申请的大小，如果小于MINSIZE，则返回MINSIZE。
//    如果大于MINSIZE，则加上3*SIZE_SZ（每个SIZE_SZ的大小相当于一个指针大小）的大小，然后再将其末三位清零。
#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</code></pre></details></li></ul><ul id="072328b7-dce7-4d2b-9ebf-b1716332b506" class="toggle"><li><details open=""><summary><strong>2、会用到的数据结构：smallbin、largebin</strong></summary><p id="19e45597-83a8-4511-93d5-dfbb3b80f94c" class=""><strong>smallbins：</strong></p><figure id="d43eb53e-54be-4b2b-b668-f130035d282e" class="image"><a href="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/Untitled.png"><img style="width:621.5625px" src="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/Untitled.png"/></a></figure><blockquote id="e8cdc72d-93cf-492d-b79c-dd2ad586b69f" class=""><mark class="highlight-red">注意！每个 smallbin 链表在初始化时都会生成一个头结点。</mark></blockquote><p id="797db03d-cfd1-4f5d-adcf-03418af09d4b" class=""><strong>largebins：</strong></p><figure id="f6008d8d-77b6-46b7-b03c-45963a343882" class="image"><a href="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/Untitled%201.png"><img style="width:528px" src="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/Untitled%201.png"/></a></figure></details></li></ul><ul id="1d8737ba-52bf-4329-b7f4-b8a63de3bbce" class="toggle"><li><details open=""><summary><strong>3、会用到的一些检查函数：do_check_malloced_chunk、do_check_remalloced_chunk</strong></summary><p id="a26f5ca9-4010-47b8-acc5-0027fee14305" class=""><strong>do_check_remalloced_chunk函数：</strong></p><p id="a9d2bc80-dbfe-4e92-93ae-e377e40541b7" class="">针对回收再利用的块进行一些检查~</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2e2b8332-d5dd-4dee-a08d-5b7ecd1e6a95" class="code"><code class="language-Plain Text">//do_check_remalloced_chunk函数代码如下：-------------------------------------

static void do_check_remalloced_chunk(mstate av, mchunkptr p, INTERNAL_SIZE_T s) {
    // 获取块的大小(通过把chunksize中的标志位去除干净得到~)
    INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);

    // 1、如果该块不是通过 mmap 分配，检查确保块所属的 arena 正确---------------------------------
    if (!chunk_is_mmapped(p)) {
        assert(av == arena_for_chunk(p));  // 获取块所属的 arena
        // 做以下检查以确保块所属的 arena 正确
        if (chunk_non_main_arena(p))       // 如果块上面的non_main_arena标志位提示“当前块在非主 arena 中”
            assert(av != &amp;main_arena);     // 则要确保传参av对应的应该也“不是主 arena”
        else                               // 如果块上面的non_main_arena标志位提示“当前块在主 arena 中”
            assert(av == &amp;main_arena);     // 则要确保传参av对应的应该也“是主 arena”
    }

    // 2、执行do_check_inuse_chunk函数进行相关检查-----------------------------------------
    do_check_inuse_chunk(av, p);           // 关于该函数的定义详见“free函数-2、会用到的一些检查”，简单来说，它执行了以下工作~👇
																				   // 1、查看当前chunk是否满足“正在使用”，同时用do_check_chunk检查其合法性
																					 // 2、然后查看当前chunk的前后chunk，如果是freechunk对他们使用do_check_free_chunk的合法性

		// 3、然后进行以下一系列检查----------------------------------------------------------
    // 3.1块大小合法性的检查
    assert((sz &amp; MALLOC_ALIGN_MASK) == 0); // 确保块大小符合对齐要求
    assert((unsigned long)(sz) &gt;= MINSIZE);// 确保块大小&gt;=最小块大小
    // 3.2块的内存对齐检查
    assert(aligned_OK(chunk2mem(p)));      // 确保块的内存对齐正确
    // 3.3被回收的块是否比“要请求的大小”大，但是大的量又不超过MINSIZE
    assert((long)(sz) - (long)(s) &gt;= 0);          // 被回收的块是否比“要请求的大小”大
    assert((long)(sz) - (long)(s + MINSIZE) &lt; 0); // 但是大的量又不超过MINSIZE
}</code></pre><p id="637ddc4a-21ce-47f3-923c-fbcd80fe04fe" class=""><strong>do_check_malloced_chunk：</strong></p><p id="1822e813-10d3-446c-b745-6936f25b758c" class="">emmm搁这套了个娃~</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="691306da-7cec-45f1-825b-fa3cf6e234d3" class="code"><code class="language-C">do_check_malloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s){
  /* same as recycled case ... */
  do_check_remalloced_chunk (av, p, s);

  /*
     ... plus,  must obey implementation invariant that prev_inuse is
     always true of any allocated chunk; i.e., that each allocated
     chunk borders either a previously allocated and still in-use
     chunk, or the base of its memory arena. This is ensured
     by making all allocations from the `lowest&#x27; part of any found
     chunk.  This does not necessarily hold however for chunks
     recycled via fastbins.
   */
	
	// 这段是为了验证“freechunk合并机制”是否正确执行
  assert (prev_inuse (p));    // 确保指针 p 所指向的内存块的前一个内存块已经被使用，如果没有被使用，则断言失败，程序停止执行。
  //#define prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)
}
</code></pre></details></li></ul><h3 id="17d0427e-38bb-808f-a184-e609da5808da" class="">3-free专用前置代码</h3><ul id="0c3cbc55-7981-42da-b3d4-d800db2d2459" class="toggle"><li><details open=""><summary><strong>1、会用到的一些相关宏：malloc_state的flags标志位相关、对齐相关、找fastbin、其他</strong></summary><p id="62fc8a6f-4add-4218-bbfb-776ce4dec603" class="">代码如下</p><blockquote id="1e3f7ab1-83eb-4414-9292-19ae0afb8bee" class="">这里虽然说是“宏”，但实际上是函数</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d4ae23ef-a33d-4b7e-bad4-9ae1d08c9b3a" class="code"><code class="language-Plain Text">//1、mallocc_state相关================
//1.1、flags标志位
//注意：为了使得 have_fastchunks 在启动时为真（因为静态变量会被零填充），其真假值被反向处理（也就是0表示真，1表示假）
#define have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)
#define clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)
#define set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)
//检查一片内存区域是否是连续分配的，这是用来检查整个堆区的，通过看整个堆区的flags标志位
#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)
//设置NONCONTIGUOUS_BIT标志位
#define set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)


//2、对齐相关=========================
//2.1、检查
//检查给定的内存块指针 p 是否正确对齐，如果未对齐，返回1，具体操作过程如下：
//1、先是进行(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p))，其中：
//    MALLOC_ALIGNMENT 是内存分配器要求的最小对齐值；SIZE_SZ 则是 sizeof(size_t)，表示系统中 size_t 类型的大小，在32位系统上为4字节，在64位系统上为8字节。
//    如果 MALLOC_ALIGNMENT 等于 2 * SIZE_SZ，则直接使用指针 p（此时p指向块data部分）；否则，调用 chunk2mem(p) 函数（此时p指向块头）。
//2、然后把指针转换为 uintptr_t 类型，这是一种无符号整数类型。
//3、最后和MALLOC_ALIGN_MASK 做按位与，其中：
//    MALLOC_ALIGN_MASK 是一个掩码，通常= 2 * SIZE_SZ -1
//    通过将指针地址与这个掩码进行按位与操作，我们可以得到该地址在对齐边界内的偏移量。如果结果不是0，则说明该地址没有按照指定的边界对齐。
#define misaligned_chunk(p) \
  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \
   &amp; MALLOC_ALIGN_MASK)
#define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)


//3、找fastbin=======================
//这里返回的是对应的那条fastbin链表的地址
#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])


//4、其他=============================
//4.1、针对条件表达式的一个嵌套修饰
//这是gcc提供的一个用来对话编译器，优化代码执行路径的宏定义。当你要是用某个比较表达式，同时又知道这个比较表达式的大概率结果时，你可以给比较表达式套上该语句进行优化。
//例如：
//    if (__builtin_expect(x != 0, 0)) {
//        // 这个分支不常见（x != 0）
//    } else {
//        // 这个分支更常见（x == 0）
//    }
//在这个例子中，知道表达式 x != 0 的结果大概率是0。因此我们给这个表达式套上了该语句。这将会使得编译器对else分支里面的语句做加速处理，对if分支里面的语句做减速处理（比如不做预处理加速）。
# define __builtin_expect(expr, val) (expr)</code></pre></details></li></ul><ul id="6a33bf53-8a66-49a1-bcdb-8dfebbf4942a" class="toggle"><li><details open=""><summary><strong>2、会用到的一些检查函数：check_inuse_chunk、do_check_chunk、do_check_free_chunk</strong></summary><p id="6863fbbc-32f6-42a1-bca7-76eab5a0a931" class=""><strong>check_inuse_chunk函数：</strong></p><p id="b901d878-fcb3-49ba-ab4a-82e22f885b61" class="">1、查看当前chunk是否满足“正在使用”，同时用do_check_chunk检查其合法性</p><p id="771a5890-f931-4ff7-9823-97ee65bb1559" class="">2、然后查看当前chunk的前后chunk，如果是freechunk对他们使用do_check_free_chunk的合法性</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9941b02d-3066-45c9-9bfd-fdb76fa153df" class="code"><code class="language-Plain Text"># define check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)
do_check_inuse_chunk (mstate av, mchunkptr p){//传参介绍：av是堆地址空间，p是块指针
  mchunkptr next;

	// 1、调用do_check_chunk函数，进行安全性检查
  do_check_chunk (av, p); 

  if (chunk_is_mmapped (p))// 如果是mmapped块的话，因为没有next/prev没什么好查的，所以直接return掉了
    return; 

  // 2、检查当前块是否正在使用，没在使用则报错！（核心代码~）
  //ps：后面看当前块的前后块的值，这是完全出于“安全检查”的目的，而不是出于“辅助检查当前块是否正在使用”的目的
  assert (inuse (p));

	// 3、当前一个块是freechunk时去检查前一个块：
	//	（1）确保前一个块和当前块在地址上是连续的！
	//  （2）调用do_check_free_chunk函数，进行安全性检查
  next = next_chunk (p); // 获取下一个块的指针
  if (!prev_inuse (p)){
      mchunkptr prv = prev_chunk (p); // 获取前一个块的指针
      assert (next_chunk (prv) == p); // 确保前一个块和当前块在地址上是连续的
      do_check_free_chunk (av, prv);  // 调用do_check_free_chunk函数，进行安全性检查
    }

	// 4、然后就看下一个物理相邻的chunk
	//   （1）如果下一个块是topchunk，则看“它的前一个块是否在使用”“topchunk的大小大于MINSIZE”
	//   （2）如果下一个块是freechunk，则调用do_check_free_chunk函数进行检查
  if (next == av-&gt;top){ 
      assert (prev_inuse (next)); // 确保前一个块正在使用
      assert (chunksize (next) &gt;= MINSIZE); // 确保块大小大于等于最小大小
    }
  else if (!inuse (next)){        // 如果下一个块未被使用
    do_check_free_chunk (av, next); // 调用do_check_free_chunk函数进行检查
}</code></pre><p id="2aee16af-8bd1-4765-88c4-51cc6288398b" class="">do_check_free_chunk：</p><p id="49d124cb-8bfd-4c7a-844d-29ac5e456cad" class="">1、一些冗余检查</p><p id="add04404-b704-4ccb-b605-23f51c87d3d8" class="">2、一系列几种检查：<div class="indented"><p id="e191a214-ffdb-4116-b7ac-914cafd2d213" class="">（1）对齐相关检查（2）对下一个块的prev_size和当前块的size的一致性检查</p><p id="ff554e30-4500-4541-ad17-537e2010836d" class="">（3）对“块合并机制”是否成功实施的检查（4）确保当前freechunk正正确地处在某条bin链中</p></div></p><blockquote id="e2d3a801-1026-48a2-a8a2-0f593f867194" class="">没用，doublefree构建的那个假freechunk它不和别人物理相邻，所以它不会被查到它“其实没有正确地处在某条bin链中”</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="13dbc755-a644-41d7-8440-949d9e46b7a6" class="code"><code class="language-Plain Text">// 其中，do_check_free_chunk的函数定义如下：---------------------------------------------
do_check_free_chunk (mstate av, mchunkptr p){
  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA); // 计算块的大小
  mchunkptr next = chunk_at_offset (p, sz); // 获取下一个块的指针

  // 0、这里完全是一处冗余设计，其实在do_check_inuse_chunk调用该函数时，就已经做过了do_check_chunk、inuse和do_check_inuse_chunk的检查
  do_check_chunk (av, p);         // 调用do_check_chunk函数检查一下
  assert (!inuse (p));            // 确保块未被使用
  assert (!chunk_is_mmapped (p)); // 确保块不是通过 mmap 分配的

  /* 除非是一个特殊的标记块，否则必须具有正确的字段 */
  if ((unsigned long) (sz) &gt;= MINSIZE){
  
		  //1、以下这一系列检查才是比较重要的！
			// 。。。对齐相关的检查
      assert ((sz &amp; MALLOC_ALIGN_MASK) == 0);  // 确保块的大小按照块的对齐要求对齐
      assert (aligned_OK (chunk2mem (p)));     // 确保块的起始地址按照对齐要求对齐
      // 。。。对下一个块的检查
      assert (next-&gt;prev_size == sz);           // 确保下一个块的prev_size字段与当前块大小匹配
      // 。。。对“块合并机制”是否成功实施的检查
      assert (prev_inuse (p));                  // 确保前一个块正在使用
      assert (next == av-&gt;top || inuse (next)); // 确保下一个块正在使用或者是堆的顶部块
      // 。。。确保当前freechunk正正确地处在某条bin链中
      assert (p-&gt;fd-&gt;bk == p); // 确保前向链接正确
      assert (p-&gt;bk-&gt;fd == p); // 确保后向链接正确
    }
  else /* 特殊标记块，要求标记块的大小始终是 SIZE_SZ */
    assert (sz == SIZE_SZ); // 确保标记块的大小是 SIZE_SZ
}</code></pre></details></li></ul><h3 id="1860427e-38bb-80cb-bbf0-f2bce215779b" class="">4-其他相关函数的前置代码</h3><ul id="1860427e-38bb-806b-ad7e-f5c606b43103" class="toggle"><li><details open=""><summary><strong>1、会用到的一些相关宏：通用unlink操作</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1860427e-38bb-809b-a4f8-de56c6c4a987" class="code"><code class="language-Plain Text">// 1、通用unlink操作
// 这可以把一个chunk给unlink出任何一个链表
/* Take a chunk off a bin list */
#define unlink(AV, P, BK, FD) {                                            \
    FD = P-&gt;fd;								      \
    BK = P-&gt;bk;								      \
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \
      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \
    else {								      \
        FD-&gt;bk = BK;							      \
        BK-&gt;fd = FD;							      \
        if (!in_smallbin_range (P-&gt;size)				      \
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {		      \
	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \
		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \
	      malloc_printerr (check_action,				      \
			       &quot;corrupted double-linked list (not small)&quot;,    \
			       P, AV);					      \
            if (FD-&gt;fd_nextsize == NULL) {				      \
                if (P-&gt;fd_nextsize == P)				      \
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \
                else {							      \
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \
                  }							      \
              } else {							      \
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \
              }								      \
          }								      \
      }									      \
}</code></pre></details></li></ul><h1 id="219b382d-9ddd-49f1-b73d-081c0a4cf532" class="block-color-default_background">二、malloc函数执行流程</h1><h3 id="9efa7bcd-5db0-4ae4-b1f0-ca8f0efb6f2b" class=""><strong>1-过程简介</strong></h3><ul id="ace5df45-42d8-4376-8eef-1714ddb32a60" class="toggle"><li><details open=""><summary>1、<strong>一些预处理</strong></summary><p id="17b0427e-38bb-80b2-a6b9-c6c2ef897688" class="">（1）在libc_malloc函数里面，执行malloc_hook并对arena上锁，</p><p id="1750427e-38bb-8005-8b0a-d7f708ea0a86" class="">（2）然后跳转到int_malloc函数（后续操作都在该函数里），对申请块大小做对齐：先加上两个指针大小，再向0x8或0x10对齐</p><p id="1750427e-38bb-80fe-934d-e649d02ceab9" class="">（3）如果当前线程还没有malloc_state，则做堆初始化操作</p></details></li></ul><ul id="d555bed5-cd12-43fe-a0f7-d481f702e208" class="toggle"><li><details open=""><summary>2、若请求的块大小&lt;=get_max_fast，<strong>尝试回收fastbin</strong></summary><p id="1750427e-38bb-806e-b0e2-d9e6bfab3e7e" class="">（1）找对应idx下面有没有块</p><p id="1750427e-38bb-80d7-ae5e-f3e7a865632a" class="">（2）如果有，对其做安全检查，如下：<div class="indented"><p id="17a0427e-38bb-80c1-8d8c-ff5af940f56f" class="">{1} “pop出的块大小”是否与“请求大小对应的fastbin索引”匹配</p><p id="17a0427e-38bb-8063-9af3-f0b1e8221f2d" class="">{2} <mark class="highlight-blue_background">调用check_remalloced_chunk函数进行安全检查</mark></p></div></p><p id="17a0427e-38bb-80ef-a745-e6354c9dfcec" class="">（3）然后把他的内容全部初始化为’\0’然后返回给用户<div class="indented"><blockquote id="1750427e-38bb-8040-be28-f82567adac78" class="">注意：这里头部相关信息是一点都不设置，包括所有标志位、size等都没设置<p id="1860427e-38bb-80a3-b001-eb2c1b0e5a74" class=""><mark class="highlight-red_background">也就是说，没有设置物理相邻下一个chunk的P位信息为=1，这是因为在free一个fastchunk的时候本来就没有把下一个chunk的P位设置为=0（也就是fastchunk无论是否被使用，P位都是=1的）</mark></p></blockquote></div></p></details></li></ul><ul id="1750427e-38bb-8090-9600-f61c0ea36316" class="toggle"><li><details open=""><summary>3、<strong>尝试回收smallbin</strong></summary><p id="1750427e-38bb-80c0-afd5-cb26f2efe84d" class="">尝试从对应bin[idx]中取出一个块，然后判断取出结果：<div class="indented"><p id="17a0427e-38bb-80dd-848d-e0ba0a83e2b1" class="">{1} 如果得到bin，就表示没有块可以取出，跳出smallbin回收</p><p id="17a0427e-38bb-8056-8060-fe168472d488" class="">{2} 如果得到0，就表示bin数组和malloc_state尚未初始化，则调用malloc_consolidate函数初始化bin数组和malloc_state，然后跳出smallbin回收</p><p id="17a0427e-38bb-80f2-9051-c7cd9942b0b6" class="">{3} 如果是得到一个正常的victim块，则做处理后返回给到用户<div class="indented"><p id="1750427e-38bb-80b9-a3aa-c9c52cbaea82" class="">① 安全检查：<div class="indented"><p id="17a0427e-38bb-8079-a5ed-dab4a729dce9" class=""><mark class="highlight-blue_background">看victim-&gt;bk-&gt;fd是否等于victim</mark>；</p><p id="17a0427e-38bb-80d2-8ff9-f284f67c1e0a" class=""><mark class="highlight-blue_background">调用check_malloced_chunk函数检查；</mark></p></div></p><p id="17a0427e-38bb-80f8-bcca-d029a7f2b8aa" class="">② 将 victim 从 对应的small_bin 链表中移除</p><p id="17a0427e-38bb-80c0-9b52-c279fa6ea391" class="">③ 设置victim相关标志位<div class="indented"><blockquote id="17a0427e-38bb-809d-a5e6-f772ab1fcab4" class="">victim物理相邻下一个chunk的prev_inuse位、victim的N标志位</blockquote><blockquote id="1750427e-38bb-8072-9603-ecdb5f659b0e" class="">注意：这里不设置size</blockquote></div></p><p id="17a0427e-38bb-80ed-9e02-fc7ca0b928fd" class="">④ 对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户</p></div></p></div></p></details></li></ul><ul id="1750427e-38bb-801d-a6de-e119ab1b8478" class="toggle"><li><details open=""><summary>4、不待检查largechunk是否有可用chunk，只要此时存在fastchunk，就直接<strong>用malloc_consolidate来做fastchunk碎片块整理合并</strong></summary></details></li></ul><ul id="1750427e-38bb-8054-bb89-e69a29cbd5c5" class="toggle"><li><details open=""><summary>5、<strong>一个超级大的循环，循环中会依次进行“处理unsortedbin→回收largechunk→切割topchunk”操作，如下：</strong></summary><p id="17a0427e-38bb-808a-b0a2-c6fab170ddfb" class="">5.1、<strong>遍历地将unsortedbin里面的所有unsortedchunk整理归类</strong>，循环中会进行以下操作==========================<div class="indented"><p id="1750427e-38bb-80db-b4b4-cfb2241e99b8" class="">（1）<mark class="highlight-blue_background">安全检查：victim-&gt;size取值必须在两倍SIZE_SZ和av-&gt;system_mem之间</mark></p><p id="1750427e-38bb-8049-88ec-f694d07a47b3" class="">（2）两种可以立即取出当前unsortedchunk的情况：<div class="indented"><p id="17b0427e-38bb-8064-bead-e0c9c5591902" class="">{1} 如果取出的unsortedchunk同时满足————————————————————————<div class="indented"><p id="1750427e-38bb-8040-a8d0-d14d23d993ca" class="">① 是一个sallbin范围的请求</p><p id="1750427e-38bb-80ca-8598-fdbc9337fbfe" class="">② 当前unsorted chunk是unsorted bin 中唯一的块</p><p id="1750427e-38bb-8021-947c-f3765c533e87" class="">③ 当前unsorted chunk的大小&gt;&quot;请求大小+MINSIZE&quot;</p><p id="1750427e-38bb-8071-b519-ede2be6cdf50" class="">④ 它是上次的剩余块（即：victim==av-&gt;last_remainder）</p></div></p><p id="1750427e-38bb-801b-9f24-ee46da5c3f33" class="">    则直接拿走，操作如下：<div class="indented"><p id="1750427e-38bb-806f-a4f1-d2cbaada3d42" class="">① 分割这个unsorted chunk，割出来的剩余部分连回unsorted bin</p><p id="1750427e-38bb-800c-abb0-d97b4513b71b" class="">② 设置当前victim、剩余块的相关标志位</p><blockquote id="1750427e-38bb-8094-90fe-f4aec0419a2a" class="">victim设置size域、P标志位=1、N标志位<p id="17b0427e-38bb-80d0-86af-d258f0bd07cb" class="">remainder设置size域、P标志位=1、下一个chunk的prev_size=remainder_size</p></blockquote><p id="17b0427e-38bb-80e0-afc3-c12ca76a8b61" class="">③ <mark class="highlight-blue_background">调用check_malloced_chunk进行安全检查</mark></p><p id="17b0427e-38bb-8059-92c8-c868ba38a1f8" class="">③ 做&#x27;\0&#x27;的data部分初始化，然后返回给用户</p></div></p><p id="1750427e-38bb-80d6-a84d-eb8c2f3eda5c" class="">{2} 如果大小正好合适，则直接拿走，操作如下——————————————————————<div class="indented"><p id="1750427e-38bb-80b9-8805-e17d10a02052" class="">① 把victim从unsorted bin中unlink走</p><p id="17b0427e-38bb-80a0-8796-fe7b818ab53b" class="">② 设置当前victim的相关标志位</p><blockquote id="17b0427e-38bb-80b7-bb5f-cee6102ae347" class="">victim设置N标志位、下一个chunk的P标志位=1</blockquote><p id="17b0427e-38bb-8083-95d4-cc3638859455" class="">③ <mark class="highlight-blue_background">调用check_malloced_chunk进行安全检查</mark></p><p id="1750427e-38bb-80ff-a0ae-d90e762a1639" class="">④ 做&#x27;\0&#x27;的data部分初始化，然后返回给用户</p></div></p></div></p><p id="1750427e-38bb-8024-a958-d03a70fde137" class="">（3）前面两种情况都不符合，则将其放进smallbin和largebin中，操作如下——————————————————<div class="indented"><p id="1750427e-38bb-80dc-bca8-e6f11eb793a8" class="">{1} 把victim从unsorted bin中unlink走，然后计算其对应的smallbin&amp;largebin索引</p><p id="1750427e-38bb-8016-85d4-e61a521a9372" class="">{2} 然后根据索引找到链表中要插入位置的前一个节点记为fwd，后一个节点记为bck，其中：<div class="indented"><p id="1750427e-38bb-80e1-85b5-c4bf3f77d9a7" class="">① 如果是smallbin就是找到bins[idx]为bck，第一个节点为fwd</p><p id="1750427e-38bb-8095-8c5d-ed5f95740631" class="">② 如果是largebin就是要遵守从大到小的排列顺序找到bck和fwd</p></div></p><p id="1750427e-38bb-805f-b5f6-e27f8afc9625" class="">{3} 将其link入双向链表中（放入fwd和bck之间）</p></div></p></div></p><p id="1770427e-38bb-80d7-a26d-ddce7d0b9828" class="">5.2、<strong>尝试在largebin中回收chunk===========================================</strong><br/>（1）先尝试从申请大小所属的大小区间对应的那条large bin里取出chunk，其中———————————————<br/><div class="indented"><p id="1790427e-38bb-8005-a024-ca545bf3981f" class="">{1} 循环直到找到合适大小的块</p><blockquote id="1790427e-38bb-80d0-9a13-e0ef39d26309" class="">注意：如果有多个相同大小的合适大小的块，用fd_nextchunk的前一个chunk作为victim，这样可以避免更新fd_nextchunk链的额外时间开支</blockquote><p id="1790427e-38bb-80c1-bfef-dbe36c108ea1" class="">{2} 将victim给unlink出来</p><p id="1790427e-38bb-80d3-8e19-f8d1682e9bee" class="">{3} 切割，然后处理切割切割后的剩余块：<div class="indented"><p id="1790427e-38bb-80a6-acc9-e818a3113f12" class="">① 如果切割后剩余块大小&lt;最小块大小，则不切割，并且设置了victim的相关标志位</p><blockquote id="17a0427e-38bb-803c-895f-d41c3830325c" class="">victim的N标志位、物理相邻下一个chunk的P标志位=1</blockquote><p id="1790427e-38bb-8025-b043-c243f92e97b3" class="">② 如果切割后剩余块大小&gt;=最小块大小，则将切割后剩余块link入unsortedbin的开头，并且设置了victim、remainder的相关标志位</p><blockquote id="17a0427e-38bb-801e-9b18-e7e05257fef7" class="">victim的size字段，N标志位、P标志位=1<br/>remainder的size字段、P标志位=1、foot字段=size<br/></blockquote><p id="1790427e-38bb-8013-8490-e770b5669bbe" class="">③ 然后把切割下来的块，只是简单用check_malloced_chunk函数检查一下后，data部分初始化为&#x27;\0&#x27;，然后就返回给用户</p></div></p><p id="1790427e-38bb-80c3-8afb-cc2c241d94de" class="">{4} <mark class="highlight-blue_background">调用check_malloced_chunk做安全检查</mark></p></div></p><p id="1790427e-38bb-8031-9088-ccdc37899fcf" class="">（2）再去尝试回收比他大的bin链上的largechunk—————————————————————————————<div class="indented"><p id="17a0427e-38bb-802c-b898-c4b48037fb83" class="">这里是通过一个循环实现的，每个循环中会进行以下操作：</p><p id="17a0427e-38bb-80a4-9acb-f24e0c3d0cfe" class="">{1} 先巧妙地粗判断当前block（即一个unsigned int）里面是否还有可用的“1”，如果没有则直接跳过这个block的剩余部分，来到下一个block、下下个block....直到有一个非空block或者所有block都不行就直接去切割topchunk。</p><p id="17a0427e-38bb-80ae-b663-ecad726cad42" class="">{2} 从低到高地检查当前block中的每一位（共32位），直到其中有一位为1时退出循环，此时的bin就指向了那条链表的bin[idx]</p><p id="17a0427e-38bb-80b7-bf8f-e518414697e9" class="">{3} 因为位表也可能会产生误报，所以这里直接从对应bin里面看能否成功取出victim，如果取不出，就是误报，则更新位表并移动bit</p><p id="17a0427e-38bb-8049-9cbb-ec021f566805" class="">{4} <mark class="highlight-blue_background">针对所取出的块的大小的安全检查：断言victim块大小&gt;=请求大小</mark></p><p id="17a0427e-38bb-80d8-93ec-e5d5afdf2c7d" class="">{5} 将victim从largebin中给unlink出来</p><p id="17a0427e-38bb-80e6-ae4f-fb2c380c6d3d" class="">{6} 如果剩余块小于最小块大小，不切割，并设置victim相关标志位<div class="indented"><blockquote id="17a0427e-38bb-80cd-8f02-efc74995f469" class="">设置victim的N标志位、victin物理相邻下一个chunk的P标志位为1</blockquote></div></p><p id="17a0427e-38bb-8020-90db-cc4d09509621" class="">{7} 如果剩余块大于最小块大小，则切割下来，并且设置victim和剩余块remainder的相关标志位，具体操作如下：<div class="indented"><p id="17a0427e-38bb-8027-bc3e-d966f5b96d04" class="">① 将remainder给link入unsortedbin的开头</p><p id="17a0427e-38bb-8002-abb6-e3c797c76863" class="">② 将remainder声明为av-&gt;last_remainder</p><p id="17a0427e-38bb-8014-b9b8-db8aa66d6ef2" class="">③ 如果remainder是largechunk大小，则将其fd_nextsize、bk_nextsize域初始化为NULL</p><p id="17a0427e-38bb-80c6-819e-cb5f907fc83f" class="">④ 设置victim、remainder的相关标志位</p><blockquote id="17a0427e-38bb-8004-89ec-ff4dd2264635" class="">设置victim的size域、P标志位=1、N标志位<p id="17a0427e-38bb-806b-aa67-d64f7fcc5d8c" class="">设置remainder的size域、P标志位=1、物理相邻下一个chunk的prev_size域=remainder_size</p></blockquote></div></p><p id="17a0427e-38bb-80d5-b8ae-c7fc6a252576" class="">{8} 调用check_malloced_chunk函数做安全检查，对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户程序</p></div></p><p id="1750427e-38bb-8087-8715-d98c20514062" class="">5.3、如果前面操作都失败了，则<strong>从topchunk中切割</strong>，或扩大arena后从topchunk中切割===============================<div class="indented"><p id="17a0427e-38bb-80f6-b29f-ff5346e39819" class="">（1）如果topchunk足够大（切割后的剩余&gt;=最小块大小），直接切割之，操作如下：<div class="indented"><p id="17a0427e-38bb-80ed-8c38-f6ce3e839793" class="">{1} 更新av-&gt;top指针</p><p id="17a0427e-38bb-8085-89ae-e05bc567470a" class="">{2} 设置victim和remainder的相关标志位</p><blockquote id="17a0427e-38bb-80db-8615-ee720145593d" class="">victim设置size域，P标志位=1，N标志位<p id="17a0427e-38bb-8014-bb6b-ed03f5d0ae2d" class="">remainder设置size域，P标志位=1</p></blockquote><p id="17a0427e-38bb-80b7-b8d4-fe25e41063cb" class="">{3} 调用check_malloced_chunk函数进行安全性检查</p><p id="17a0427e-38bb-8051-b501-f8f683f5f0d1" class="">{4} 初始化data为\0后，返回给用户</p></div></p><p id="17a0427e-38bb-8096-9475-d7df1179c53f" class="">（2）如果topchunk不够大，但是有fastchunk，则调用malloc_consolidate函数</p><p id="17a0427e-38bb-80a2-b51b-c1316fd4086f" class="">（3）如果topchunk不够大，且没有fastchunk，则调用sysmalloc函数，在其中尝试直接调用mmap分配超大chunk需求&amp;扩大topchunk</p></div></p></details></li></ul><blockquote id="324ed3cf-7f6e-46e8-96b7-a82ba061c626" class="">注意：<p id="e1cc54e2-d131-432d-93ce-2a05de83c3bf" class=""><mark class="highlight-red">malloc不会将申请到的堆块里面的内容设置为0，但是calloc会！</mark></p></blockquote><h3 id="30cf3f8d-ad17-4f4f-bdb7-4f4d3b0e3513" class=""><strong>2-示意图</strong></h3><ul id="8e2a1a88-7820-4967-9daf-0cd4b4db628e" class="toggle"><li><details open=""><summary>以x32环境下的malloc函数为例</summary><figure id="17d0427e-38bb-809f-9a76-c19a8f26fd02" class="image"><a href="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/1.png"><img style="width:959.1875px" src="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/1.png"/></a></figure><figure id="17d0427e-38bb-80fe-a126-c4ed73905d6d" class="image"><a href="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/2.png"><img style="width:959.2000122070312px" src="%E5%A0%86%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89%204577645dfc3b419b9e615a0dc389f6fa/2.png"/></a></figure></details></li></ul><h3 id="1770427e-38bb-8056-ae3a-e2954385cb4e" class="">3-源码解析</h3><blockquote id="1730427e-38bb-8060-a981-d85be28b0736" class="">源码出处：<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></blockquote><p id="1770427e-38bb-80e9-b94c-e28d64db4873" class="">先是进到libc_malloc函数，然后该函数调用_int_malloc函数去完成主要的块创建过程</p><ul id="17b0427e-38bb-809b-9f2a-ddddfa0ce92f" class="toggle"><li><details open=""><summary><strong>__libc_malloc 函数代码如下：</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17b0427e-38bb-8098-883d-eddfe063fe01" class="code"><code class="language-Plain Text">void * __libc_malloc (size_t bytes) // 参数 bytes 表示请求分配的字节数。
{
  mstate ar_ptr; // 用于表示当前线程使用的内存区域（arena）的状态。
  void *victim; // 用于存储分配到的内存地址，如果分配失败则为 NULL。

	// 1、钩子处理
  // 获取全局 malloc 钩子函数。这个钩子允许用户在实际分配发生之前插入自定义逻辑。
  void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);
  // 如果有设置 malloc 钩子并且它不是一个空指针，则调用该钩子进行内存分配。
  if (__builtin_expect (hook != NULL, 0)) // __builtin_expect 优化分支预测。
    return (*hook)(bytes, RETURN_ADDRESS (0)); // 返回钩子函数的结果。

  // 2、尝试获取当前线程绑定的 arena，并对其上锁。
  // 具体来说，该函数执行时，glibc 内部会检查当前线程是否已经有了一个关联的 arena。如果没有，它会尝试找到或创建一个新的 arena，并且在这个过程中会对全局的数据结构上锁
  arena_get (ar_ptr, bytes);

  // 3、调用_int_malloc函数获得一片内存
  victim = _int_malloc (ar_ptr, bytes); // _int_malloc 是执行实际分配工作的函数。
  
  // 4、如果第一次尝试未能成功分配内存（victim 为空），并且我们已经找到了一个可用的 arena，
  // 则重试使用另一个 arena 进行分配。
  if (!victim &amp;&amp; ar_ptr != NULL)
    {
      LIBC_PROBE (memory_malloc_retry, 1, bytes); // 发出调试信息，表明正在重试内存分配。
      
      // 尝试从其他 arena 获取内存。
      ar_ptr = arena_get_retry (ar_ptr, bytes);
      victim = _int_malloc (ar_ptr, bytes); // 再次尝试分配内存。
    }

	// 5.对当前线程绑定的arena解锁
  // 如果我们使用了一个 arena，则需要解锁它，以便其他线程可以使用它。
  if (ar_ptr != NULL)
    (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); // 解锁 arena 的互斥锁。

	// 6、安全检查
  // 断言：确保返回的内存要么是通过 mmap 分配的，要么属于当前的 arena。
  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
          ar_ptr == arena_for_chunk (mem2chunk (victim)));

  return victim; // 返回分配的内存地址，或者如果分配失败则返回 NULL。
}
// libc_hidden_def 宏用来隐藏符号，防止符号被动态链接器解析。
libc_hidden_def (__libc_malloc);</code></pre></details></li></ul><ul id="1770427e-38bb-800e-9150-feee3c06d8df" class="toggle"><li><details open=""><summary><strong>_int_malloc 函数代码如下：</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b9f3da3d-c953-4d32-a689-4f6aa9f7d421" class="code"><code class="language-C">static void *_int_malloc (mstate av, size_t bytes){
  INTERNAL_SIZE_T nb;               /* 请求的chunk的大小！ */
  unsigned int idx;                 /* 相关的 bin 索引 */
  mbinptr bin;                      /* 相关的 bin */

  mchunkptr victim;                 /* 被检查/选中的内存块 */
  INTERNAL_SIZE_T size;             /* 内存块的大小 */
  int victim_index;                 /* 内存块的 bin 索引 */

  mchunkptr remainder;              /* 拆分后的剩余内存块 */
  unsigned long remainder_size;     /* 剩余内存块的大小 */

  unsigned int block;               /* 位图遍历器 */
  unsigned int bit;                 /* 位图遍历器 */
  unsigned int map;                 /* binmap 的当前字 */

  mchunkptr fwd;                    /* 链接的临时变量 */
  mchunkptr bck;                    /* 链接的临时变量 */

  const char *errstr = NULL;

	// 1、对请求chunk大小的初始化处理-----------------------------------------------
  // 检查请求的大小是否过分大，并且往大小里面添加两个指针大小然后向8&amp;16字节对齐
  checked_request2size (bytes, nb);

  // 2、检查一下如果av==NULL，也就是没有堆区初始化是第一次malloc----------------------
  // 如果没初始化，就调用 sysmalloc来向os申请一片堆空间，然后调用alloc_perturb把chunk的全部内容设置为&#x27;\0&#x27;返回给用户
  // 之所以这么简单，是因为第一次malloc时一定不涉及那些复杂的堆块回收机制啥的
  if (__glibc_unlikely (av == NULL)){
      void *p = sysmalloc (nb, av);  //如果没初始化，就调用 sysmalloc 函数来要求os为堆区分配一片内存
																     //该函数会对“管理堆的结构体”进行初始化，细节挺多的，函数源码放下边了，因为不涉及堆pwn我就不详细写了
      if (p != NULL)
					alloc_perturb (p, bytes);  //如果初始化成功了，就调用alloc_perturb来把chunk的全部内容初始化为&#x27;\0&#x27;
      return p;
    }
	
	/********************************************
		fastbin回收部分！
	*********************************************/
  // 3、这里是fastchunk的申请代码，开发者因为自以为是的疏忽所以做的安全检查很少
	// 若请求的块大小&lt;=get_max_fast，则尝试从对应的fastbin中回收块
	if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) {
    
    idx = fastbin_index(nb);            // 确定请求大小对应的fastbin索引
    mfastbinptr *fb = &amp;fastbin(av, idx);// 获取对应的fastbin链表指针，记为fb
    mchunkptr pp = *fb;                 // 获取该fastbin链表的第一个块，记为pp
    // 3.1、从fastbin中pop出一块可用于分配的fastchunk，存放于变量victim中
    do {
        victim = pp;
        if (victim == NULL)  // 如果当前块为空，则跳出循环
            break;
    } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);
		//while的条件这里是一个自旋操作，意义是为了从当前fastbin中取出victim，自旋是为了应对多线程

    // 如果找到可用的快速块
    if (victim != 0) {
        // 3.2、安全检查：“pop出的块大小”是否与“请求大小对应的fastbin索引”匹配，如果不匹配则可能存在内存损坏，报错之
        if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) {
            errstr = &quot;malloc(): memory corruption (fast)&quot;;
            errout:
              malloc_printerr (check_action, errstr, chunk2mem (victim), av);
              return NULL;
        }
        // 3.3、调用函数，检查这个回收的块是否安全！！！
        check_remalloced_chunk(av, victim, nb);
				// 3.4、对分配的块的内容进行&#x27;\0&#x27;初始化然后返回给用户
        void *p = chunk2mem(victim);       // 获取分配块的指针
        alloc_perturb(p, bytes);           // 对分配的块进行初始化，里面内容全部初始化为&#x27;\0&#x27;
        return p;                          // 返回分配块的指针
    }
	}

	/********************************************
		smallbin回收部分！
	*********************************************/
	//4、这是smallchunk的申请代码
	// 我们可以在unosortedbin遍历前就先尝试好smallbin，这是因为每条smallbins链表都对应了一个固定的大小。
  // (对于一个大型chunk申请，我们需要等到unsorted bins被处理完才能找到最佳匹配。但对于小型请求，匹配总是精确的，所以我们现在可以检查，这更快。)
  // 然后后面unsortedbin遍历时要是遇到合适的small大小的块会直接拿来用，如果没遇到则也不需要后续再尝试smallbin，所以 我们这里后续就不用再尝试遍历smallbin了！
	if (in_smallbin_range(nb)) {   //检查当前chunk的大小是否小于largebin的最小大小，判断其是否为一个smallchunk申请

    idx = smallbin_index(nb);    //获得对应的smallbin链表索引
    bin = bin_at(av, idx);       //获得对应的smallbin链表，存为变量bin

		// 4.1尝试从bin中取出一个块
		// 4.1.1如果得到bin，就表示没有块可以取出，跳出smallbin回收
    // 如果 bin 中有块可用，也就是它不只有一个空的头节点
    // 初始化的smallbin每个链表会有一个空的头节点，然后第一次调用malloc去申请smallbin时才会设置所有头节点的bk域往回指
    if ((victim = last(bin)) != bin) {    // bin这里是bin[idx]，所以这里victim=last(bin)是取出对应的那条smallbin链表中的最后一个元素。如果他!=bin[idx],则要么表示malloc_state里面的bin域没有初始化，要么表示是取到了那个堆块

        // 4.1.2如果得到0，就表示bin数组和malloc_state尚未初始化，则调用malloc_consolidate函数初始化bin数组和malloc_state
        if (victim == 0) 
            malloc_consolidate(av);   //调用malloc_consolidate函数
        //4.2如果是得到一个正常的victim块，则做处理后返回给到用户---------------------------------------
        else {
            bck = victim-&gt;bk;            // 获取 victim 块的后继
            // 4.2.1安全检查：看victim-&gt;bk-&gt;fd是否等于victim
            // 这是为了防止链表被攻击者破坏
            if (__glibc_unlikely(bck-&gt;fd != victim)) {
                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;
                goto errout;
            }
            // 4.2.2设置victim物理相邻下一个chunk的prev_inuse位
            set_inuse_bit_at_offset(victim, nb);    
            // 4.2.3将 victim 从 bin 链表中移除
            bin-&gt;bk = bck;
            bck-&gt;fd = bin;
            // 4.2.4设置 victim 块的 N标志位
            if (av != &amp;main_arena)
                victim-&gt;size |= NON_MAIN_ARENA;
            // 4.2.5调用check_malloced_chunk函数检查已分配的块
            check_malloced_chunk(av, victim, nb);
            // 4.2.6对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户
            void *p = chunk2mem(victim);  // 获取分配块的指针
            alloc_perturb(p, bytes);      // 对分配的块进行初始化
            return p;                     // 返回分配的块指针
            // 注意：
            // 无需设置victim的size域，这是因为size域的意义是为了在unsorted bin中做回收&amp;在largebin中做排序
            // 如果这个smallchunk是来自用户直接的free，就无需size。如果这个small
        }
    }
	}


	//5、在继续之前先合并fastchunk，顺便计算了一下如果要申请的块是largebin大小时它的idx
	//虽然在甚至还未检查largechunk是否有可用chunk之前就清空所有快速分配块可能看起来有些过度，但这样可以避免通常与快速分配块相关的碎片化问题。
	//此外，在实践中，程序通常有一系列小型或大型请求，但较少混合情况，因此在大多数程序中并不经常调用合并操作。而那些频繁调用合并操作的程序通常也容易碎片化。
	else{
	  idx = largebin_index (nb);   // 计算对应大块的索引
	  // 如果有fastchunk，则调用malloc_consolidate对所有fastchunk进行合并操作
	  if (have_fastchunks (av))
	    malloc_consolidate (av);
	}

	/********************************************
		遍历unsorted bin部分！
	*********************************************/
  for (;; ){      //之所以会有这个外循环，是因为while循环这里可能会切割大块的chunk而导致有新的剩余chunk加入unsorted bin
      int iters = 0;
      
      // 6、遍历unsorted bin处理它里面的所有unsortedchunk-------------------------------------------
      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)){     // victim被设置指向那个unsorted chunk！
          bck = victim-&gt;bk;    //
          
          // 6.1安全检查：victim-&gt;size取值必须在两倍SIZE_SZ和av-&gt;system_mem之间
          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))
              malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,chunk2mem (victim), av);
          size = chunksize (victim);

					/********************************************
						尝试使用唯一一个剩余块
					*********************************************/
          // 6.2、尝试使用唯一一个剩余块---------------------------------------------------------------------------------------------
	        // 如果取出的第一个unsortedchunk同时满足：（1）是一个sallbin范围的请求（2）当前unsorted chunk是unsorted bin 中唯一的块（3）当前unsorted chunk的大小&gt;&quot;请求大小+MINSIZE&quot;（4）它是上次的剩余块（av-&gt;last_remainder）
	        // 则尝试使用之（切割成合适大小，并且把割出来的剩余chunk连回unsorted bin）。
          // 意义：这有助于提高连续小请求的局部性。这是最佳适配的唯一例外，仅适用于没有精确匹配的小块。
          if (in_smallbin_range (nb) &amp;&amp;                       // 如果nb是小请求的范围
              bck == unsorted_chunks (av) &amp;&amp;                  // 如果当前unsorted chunk是unsorted bin 中唯一的块
              victim == av-&gt;last_remainder &amp;&amp;                 // 如果当前unsorted chunk是上次的剩余块
              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) // 如果当前unsorted chunk的大小大于请求大小加上最小块大小
            {
              // 6.2.1分割这个unsorted chunk，并且把割出来的剩余chunk连回unsorted bin
              remainder_size = size - nb;                      // 计算剩余块的大小
              remainder = chunk_at_offset (victim, nb);        // 获取剩余块的地址
              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;  // 重新连接剩余块到未排序 bin 中
              av-&gt;last_remainder = remainder;                  // 更新最后一个剩余块
              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); // 设置剩余块的前驱和后继指针为未排序 bin
              if (!in_smallbin_range (remainder_size))         // 如果连回unsorted bin的剩余chunk还是large chunk大小，则将其fd_nextsize、bk_nextsize域初始化为0
                 {
                  remainder-&gt;fd_nextsize = NULL;
                  remainder-&gt;bk_nextsize = NULL;
	               }
              // 6.2.2设置当前块、剩余块的头部相关信息
              // 6.2.2.1设置当前块的相关信息，设置size、标记prev_inuse（因为前后合并机制）、如果不是主分配区则标记NON_MAIN_ARENA
							// 这里会无脑设置prev_inuse，这或许会成为一个漏洞利用点
              set_head (victim, nb | PREV_INUSE |(av != &amp;main_arena ? NON_MAIN_ARENA : 0));
              // 6.2.2.2设置剩余块的头部和脚部信息，标记prev_inuse，且标记下一个chunk的prev_size
              set_head (remainder, remainder_size | PREV_INUSE); //这里是设置剩余块的size字段，包括设置了prev_inuse标志位
              set_foot (remainder, remainder_size);              //这里是设置下一个chunk的prev_size字段
              // 6.2.3调用check_malloced_chunk进行安全检查
              check_malloced_chunk (av, victim, nb);
              // 6.2.4对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户程序
              void *p = chunk2mem (victim);      // 将块转换为分配的内存区域
              alloc_perturb (p, bytes);           // 扰动分配的内存区域
              return p;                           // 返回分配的内存区域的指针
            }

          // 6.3把victim从unsorted bin中unlink走
          unsorted_chunks (av)-&gt;bk = bck;
          bck-&gt;fd = unsorted_chunks (av);

					/********************************************
						如果恰好大小匹配，则立即获取
					*********************************************/
					//6.3大小合适的话立即获取---------------------------------------------------------------------------------------------
          //如果恰好大小匹配，则立即获取，而不是放入 bin 中再去bin中获取
          if (size == nb)                           // 如果块的大小恰好等于请求的大小
            {
		          // 6.3.1设置当前的头部相关信息
              set_inuse_bit_at_offset (victim, size); // 设置块为已使用状态（通过设置下一个块的prev_inuse位）
              if (av != &amp;main_arena)                  // 如果不是主分配区，则设置块为非主分配区
                victim-&gt;size |= NON_MAIN_ARENA;
              // 6.3.2调用check_malloced_chunk进行安全检查
              check_malloced_chunk (av, victim, nb);
              // 6.3.3对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户程序
              void *p = chunk2mem (victim);          // 将块转换为分配的内存区域
              alloc_perturb (p, bytes);              // 把data部分全部设置成&#x27;\0&#x27;
              return p;                              // 返回分配的内存区域的指针
            }

          /********************************************
						准备将块放入对应的smallbin&amp;largebin中
					*********************************************/
					//6.4将块放入对应的smallbin&amp;largebin中--------------------------------------------------------------------------
					//6.4.1获取其“要插入的位置”，以准备将块放入smallbins&amp;largebin里
					//6.4.1.1如果块大小在small bin 范围内，获取其“要插入的位置”
					if (in_smallbin_range (size))
					 {
              victim_index = smallbin_index (size);      // 计算小型 bin 的索引
              bck = bin_at (av, victim_index);           // 对应的bins[idx]这个元素的地址，存放在bck
              fwd = bck-&gt;fd;                             // fwd里面存放着bins[idx]-&gt;fd也就是链表的第一个节点的地址
            }
          //6.4.1.2如果块大小在large bin 范围内，获取其“要插入的位置”
          else
           {
              victim_index = largebin_index (size);      // 计算大型 bin 的索引
              bck = bin_at (av, victim_index);           // bck被初始化为对应的bins[idx]这个元素的地址
              fwd = bck-&gt;fd;                             // fwd被初始化为链表的第一个节点的地址

              // 这一段就是比较当前要回收的unsorted chunk大小，找到合适的插入位置，因为large bin链表要求从小到大有序排列
              if (fwd != bck)
                {
                  // 将size变量的P标志位设置为1，这是为了后面比较操作时简化一些步骤
                  size |= PREV_INUSE;
                  /* 如果比最小块还小，跳过下面的循环 */
                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);
                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))
                    {
                      fwd = bck;
                      bck = bck-&gt;bk;

                      victim-&gt;fd_nextsize = fwd-&gt;fd;
                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;
                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                    }
                  else
                    {
                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);
                      while ((unsigned long) size &lt; fwd-&gt;size)
                        {
                          fwd = fwd-&gt;fd_nextsize;
                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);
                        }

                      if ((unsigned long) size == (unsigned long) fwd-&gt;size)
                        // 始终插入在第二个位置
                        fwd = fwd-&gt;fd;
                      else
                        {
                          victim-&gt;fd_nextsize = fwd;
                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
                          fwd-&gt;bk_nextsize = victim;
                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                         }
                      bck = fwd-&gt;bk;
                    }
                }
              else
	                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;
            }

					//6.4.2根据刚刚获取的“要插入的位置”，进行插入
          mark_bin (av, victim_index);                    // 标记对应 bin 的使用
          victim-&gt;bk = bck;                               // 设置后继指针
          victim-&gt;fd = fwd;                               // 设置前进指针
          fwd-&gt;bk = victim;                               // 设置前进指针的后继指针
          bck-&gt;fd = victim;                               // 设置后继指针的前进指针

#define MAX_ITERS       10000
          // 如果迭代次数超过最大值，跳出while遍历unsorted bin的循环，以此防止死循环~
          if (++iters &gt;= MAX_ITERS)
              break;
		  }//至此，while遍历unsorted bin的循环结束！


      /********************************************
		    尝试从对应大小区间的那条large bin里取出chunk部分！
	    *********************************************/
			// 7、这里尝试从所申请chunk对应的大小区间的那条largebin里面找合适的chunk----------------------------------------------------------------
			// 这里如果到这一步然后要申请的是small范围的chunk还没申请到，那我们就会直接在后面去切割topchunk了
      if (!in_smallbin_range (nb))
        {                        
          bin = bin_at (av, idx);                          // 这使bin变量中存放了bin[idx]这个元素的地址

          //7.1如果不能同时符合以下两个条件，就证明“对应大小区间的那条large bin里没法取出我们要的chunk”，就不必走if后面的部分：
          //（1）对应大小区间的那条large bin链表不为空   （2）那条largebin里面的最大块足够大      
          if ((victim = first (bin)) != bin &amp;&amp;             //  对应大小区间的那条large bin链表不为空，即“bin[idx]指向的是一条非空largebin链表”
              (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) // 这条非空largebin链表里面的最大那个块足够大（即&gt;=nb）
           {
              // 7.2循环直到找到合适大小的块
              victim = victim-&gt;bk_nextsize;                // 获取下一个更大的块（注意如果bk链是a:1-b:2-c:2，则bk_nextchunk链是a:1-c:2）
              while (((unsigned long) (size = chunksize (victim)) &lt;(unsigned long) (nb))) // 循环直到找到合适大小的块，循环结束时，将有victim的size&gt;=nb
                  victim = victim-&gt;bk_nextsize;
              // 7.3这是在多个largechunk大小相同时，不pop出大小相同的最后一个（bk_nextchunk指向的那个），以避免必须重新更新跳链（bk_nextchunk链），节约时间开支
              // 示例：如果bk链是a:1-b:2-c:2-d:2，对应的bk_nextchunk链就是a:1-d:2。前面while循环找到的合适的块是d，如果直接取出d就需要把bk_nextchunk链更新为a-c，这样时间开支较大，不如改成直接取出c然后不更新bk_nextchunk链。
              if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)
                  victim = victim-&gt;fd;
							// 7.4unlink
              remainder_size = size - nb;                  // 计算剩余块的大小
              unlink (av, victim, bck, fwd);               // 将找到的块从链表中移除
              // 7.5对于剩余块的处理，以及设置一些标志位
              // 7.5.1如果切割后剩余块大小&lt;最小块大小，则不切割，并简单设置victim的相关标志位（）
              if (remainder_size &lt; MINSIZE)               // 如果剩余块大小小于最小块大小
               {
                  set_inuse_bit_at_offset (victim, size); // 设置块P标志位为“已使用状态”
                  if (av != &amp;main_arena)
                      victim-&gt;size |= NON_MAIN_ARENA;     // 如果不是主分配区，则设置块标志位为“非主分配区”
               }
              // 7.5.2如果切割后剩余块大小&gt;=最小块大小，剩余块给他放进unsortedbin里
              else
               {
                  remainder = chunk_at_offset (victim, nb); // 获取剩余块的地址
                  /* 我们不能假设未排序列表为空，因此必须在这里执行完全插入。 */
                  // 7.5.2.1将切割后剩余块link入unsortedin的开头
                  // 7.5.2.1.1获取bck和fwd
                  bck = unsorted_chunks (av);              // 获取unsorted bin 的指针
                  fwd = bck-&gt;fd;                           // 获取前向指针
								  if (__glibc_unlikely (fwd-&gt;bk != bck)){
                      errstr = &quot;malloc(): corrupted unsorted chunks&quot;;
                      goto errout;
                  }
                  // 7.5.2.1.2将切割后剩余块remainder插入bck和fwd之间
                  remainder-&gt;bk = bck;                    
                  remainder-&gt;fd = fwd;
                  bck-&gt;fd = remainder;
                  fwd-&gt;bk = remainder;
                  // 7.5.2.2如果剩余块大小在largebin范围内，对它的fd_next_chunk和bk_next_chunk域进行初始化
                  if (!in_smallbin_range (remainder_size)){  // 如果剩余块大小在largebin范围内，对fd_next_chunk和bk_next_chunk进行初始化
                      remainder-&gt;fd_nextsize = NULL; 
                      remainder-&gt;bk_nextsize = NULL;
                  }
                  // 7.5.2.3设置相关信息数据：
                  // victim的size字段，N标志位、P标志位=1
                  // remainder的size字段、P标志位=1、foot字段=size
                  set_head (victim, nb | PREV_INUSE |        // 设置当前块的头部和脚部信息
                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
                  set_head (remainder, remainder_size | PREV_INUSE);
                  set_foot (remainder, remainder_size);
               }
              
              // 7.6调用check_malloced_chunk函数检查分配的块是否正确
              check_malloced_chunk (av, victim, nb);
              // 7.7对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户程序
              void *p = chunk2mem (victim);               // 将块转换为分配的内存区域
              alloc_perturb (p, bytes);                    // 扰动分配的内存区域
              return p;                                    // 返回分配的内存区域的指针
           }
        }
	
      /********************************************
		    遍历其他条位于更大的大小区间的large bin部分！
	    *********************************************/
			// 8、遍历其他条large bin-----------------------------------------------------------
			// 这里它不会只尝试回收和当前要回收大小相同的bin链上的largechunk，而是会去尝试回收比他大的bin链上的largechunk
			// 并且这里会使用一个“位图”机制(binmap的设计意义就是记录对应的bin是否为空，当在 malloc 中遍历期间发现它们为空时就会设置binmap的对应位) 
      
      // 8.1、一些前置处理
      // 8.1.1、获取下一个大小的largebin的bin[idx]元素，存放在bin变量
      ++idx;                                               // idx移动到下一个 bin
      bin = bin_at (av, idx);                              // 获取对应 bin 的指针（指向bin[idx]这个元素）
      // 8.1.2、获取下一个大小的largebin的位图对应的那个unsigned int，存放在map变量。bit变量则是一个定位标，其中32位里面idx对应的那一位为1，其余位为0.
      block = idx2block (idx);                             // 计算索引 idx 对应在位图（bitmap）中的块（block）位置
      map = av-&gt;binmap[block];                             // 获取 binmap 中largebin对应的那张位图
      bit = idx2bit (idx);                                 // 计算那张位图里idx对应的bin的位置，存为bit

			// 8.2、循环进行以下操作：
      for (;; )
        {
	        // 8.2.1、先巧妙地粗判断当前block（即一个unsigned int）里面是否还有可用的“1”，如果没有则直接跳过这个block的剩余部分，来到下一个block、下下个block....直到有一个非空block非空或者所有block都不行就直接去切割topchunk。
	        // bit &gt; map的含义：因为在binmap里面，越大的largebin链对应的是值越高的二进制位，所以如果刚进入这个for时，就已经bit &gt; map了，那就证明当前block在比当前bit的那个位值更高的所有位上都不存在“1”，那就不用在现在这个block里面纠缠了
          // bit==0的含义：因为我们查看一个block里面是否有可用的“1”，是通过不停把bit右移来实现的，如果一直右移到bit==0还没有匹配到“1”，那就说明当前block里面没有可用的&quot;1&quot;了
          if (bit &gt; map || bit == 0)         /* 这里是一个“或”逻辑 */
            {
              do
                {
                  if (++block &gt;= BINMAPSIZE) /* 超出了 bin 的范围 */
                    goto use_top;
                }
              while ((map = av-&gt;binmap[block]) == 0);

              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));     // 更新 bin 指针
              bit = 1;                                        // 重置 bit
            }

          // 8.2.2、从低到高地检查当前block中的每一位（共32位），直到其中有一位为1时退出循环，此时的bin就指向了那条链表的bin[idx]
          while ((bit &amp; map) == 0)
            {
              bin = next_bin (bin);                           // 获取下一个 bin 的指针
              bit &lt;&lt;= 1;                                      // 移动 bit 里面的那个1的位置，越往左移
              assert (bit != 0);
            }

          victim = last (bin);                                // 获取 bin 中最后一个块

					// 8.2.3 因为位表也可能会产生误报，所以这里直接从对应bin里面看能否成功取出victim，如果取不出，就是误报，则更新位表并移动bit
          /* 如果是误报（空 bin），则清除位。 */
          if (victim == bin)
            {
              av-&gt;binmap[block] = map &amp;= ~bit; /* 透过写 */    // 清除对应位的值
              bin = next_bin (bin);                           // 获取下一个 bin 的指针
              bit &lt;&lt;= 1;                                      // 移动 bit 位
            }
          else
            {
	            // 8.2.4 针对所取出的块的大小的安全检查:断言victim块大小&gt;=请求大小
              size = chunksize (victim);                      // 获取块的大小
              assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); // 断言victim块大小&gt;=请求大小

              remainder_size = size - nb;                      // 计算剩余块的大小
              // 8.2.5 将victim从largebin中给unlink出来
              unlink (av, victim, bck, fwd);                  // 将块从链表中移除
              // 8.2.6 如果剩余块小于最小块大小，不切割，并设置victim相关标志位（设置victim的N标志位、victin物理相邻下一个chunk的P标志位为1）
              if (remainder_size &lt; MINSIZE)                   // 如果剩余块大小&lt;“最小块大小”
                {                   
                  set_inuse_bit_at_offset (victim, size);     // 设置块为已使用状态
                  if (av != &amp;main_arena)
                      victim-&gt;size |= NON_MAIN_ARENA;         // 如果不是主分配区，则设置为非主分配区
                }
							// 8.2.7 如果剩余块大于最小块大小，则切割下来，并且设置victim和剩余块remainder的相关标志位
              /* 分割 */
              else
                {
                  remainder = chunk_at_offset (victim, nb);   // 获取剩余块的地址

									// 8.2.7.1 将remainder给link入unsortedbin的开头处
                  /* 我们不能假设未排序列表为空，因此必须在这里执行完全插入。 */
                  bck = unsorted_chunks (av);                  // 获取未排序 bin 的指针
                  fwd = bck-&gt;fd;                               // 获取前向指针
								  if (__glibc_unlikely (fwd-&gt;bk != bck))
								    {
                      errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;; // 发生错误
                      goto errout;                                  // 跳转到错误处理
                    }
                  remainder-&gt;bk = bck;                           // 设置剩余块的前驱和后继指针
                  remainder-&gt;fd = fwd;
                  bck-&gt;fd = remainder;
                  fwd-&gt;bk = remainder;

                  // 8.2.7.2 将remainder声明为av-&gt;last_remainder
                  if (in_smallbin_range (nb))
	                    av-&gt;last_remainder = remainder;
	                // 8.2.7.3 如果remainder是largechunk大小，则将其fd_nextsize、bk_nextsize域初始化为NULL
                  if (!in_smallbin_range (remainder_size))
                    {
                      remainder-&gt;fd_nextsize = NULL;             // 设置剩余块的前驱和后继指针为 NULL
                      remainder-&gt;bk_nextsize = NULL;
                    }
                  // 8.2.7.4 设置victim、remainder的相关标志位，包括：
                  // 设置victim的size域、P标志位=1、N标志位
                  // 设置remainder的size域、P标志位=1、物理相邻下一个chunk的prev_size域=remainder_size
                  set_head (victim, nb | PREV_INUSE |            // 设置当前块的头部和脚部信息
                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
                  set_head (remainder, remainder_size | PREV_INUSE);
                  set_foot (remainder, remainder_size);
                }
              // 8.2.8、调用check_malloced_chunk函数做安全检查，对分配的块做&#x27;\0&#x27;的data部分初始化，然后返回给用户
              check_malloced_chunk (av, victim, nb);
              
              void *p = chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            }
        }

    use_top:
      /********************************************
		    切割topchunk部分！
	    *********************************************/
      // 9.没得回收时我们尝试切割topchunk-------------------------------------------------------------------------------
      // 同时在切割过程中要保证topchunk还有&gt;= MINSIZE的剩余，因此如果当前请求否则会耗尽它，则会进行补充。（确保它存在的主要原因是，我们可能需要 MINSIZE 的空间来放置 sysmalloc 中的栅栏。）
      victim = av-&gt;top;                               // 获取 av-&gt;top 指针
      size = chunksize (victim);                      // 获取块的大小

			// 9.1如果topchunk足够大，直接切割之----------------------------------------
      if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)){ // 如果块大小足够大
          remainder_size = size - nb;                  // 计算剩余块的大小
          remainder = chunk_at_offset (victim, nb);     // 获取剩余块的地址
          av-&gt;top = remainder;                          // 更新 av-&gt;top 指针
          set_head (victim, nb | PREV_INUSE |           // 设置当前块的头部和脚部信息
                    (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
          set_head (remainder, remainder_size | PREV_INUSE); // 设置剩下那部分topchunk的size域和P标志位
          // 调用check_malloced_chunk函数，检查分配的块是否正确
          check_malloced_chunk (av, victim, nb);
          void *p = chunk2mem (victim);               // 将块转换为分配的内存区域
          alloc_perturb (p, bytes);                   // 扰动分配的内存区域
          return p;                                   // 返回分配的内存区域的指针
      }

      // 9.2如果topchunk不够大，但是有fastchunk，则调用malloc_consolidate函数----------------------------------------
      else if (have_fastchunks (av)){                 // 如果有快速块
          malloc_consolidate (av);                    // 合并空闲块
          // 恢复原始 bin 索引，然后这之后还会执行遍历unsortedbin附近那个外层循环的for(;;)去尝试从smallbin&amp;largebin中获得chunk！
          if (in_smallbin_range (nb))
            idx = smallbin_index (nb);
          else
            idx = largebin_index (nb);
        }

      // 9.3如果topchunk不够大，且没有fastchunk，则调用sysmalloc函数为其申请一片空间----------------------------------------
      else{
          void *p = sysmalloc (nb, av);               // 调用系统 malloc
          if (p != NULL)
            alloc_perturb (p, bytes);                 // 扰动分配的内存区域，全部设置为&quot;\0&quot;
          return p;                                   // 返回分配的内存区域的指针
      }
  }
}
</code></pre></details></li></ul><h3 id="1860427e-38bb-80c6-adbe-f9f8180d1e66" class="">4-其他相关函数</h3><p id="1860427e-38bb-803e-930d-e9f02f3a2e6f" class="">其中：</p><ul id="e3c2a687-dac9-49e6-b89d-5759b33b9062" class="toggle"><li><details open=""><summary>malloc_consolidate函数用于fastbin碎片块整理合并，详情如下：</summary><p id="2fd447ab-9c5a-4b1f-97ef-8aeafeac242e" class=""><strong>【介绍】</strong></p><p id="7e8f4b93-4512-4778-9d95-9be3c62b7e52" class="">这个函数有两种作用：<div class="indented"><p id="d9951144-51bc-4c3b-b62f-320d49c32406" class="">（1）用于合并 fastbin 中的空闲块并将它们放入 unsorted bin 中</p><p id="e58b1ade-deec-4e68-883c-fcd8facd97a5" class="">（2）也可以用于对堆进行初始化</p></div></p><p id="1840427e-38bb-809b-991e-c9d92e407dff" class=""><strong>【执行逻辑】</strong></p><p id="9511940f-a46d-4186-ba9e-77bfdfff8fc2" class="">这个函数的执行逻辑如下：<div class="indented"><p id="1860427e-38bb-8073-8e3b-f19aa220380d" class="">1、如果max_fast!=0，则合并空闲块并放入未排序链表，具体操作如下；<div class="indented"><p id="1860427e-38bb-80de-86cc-c1c1c25bf4d5" class="">1.1、修改malloc_state的fastchunk标志位为“否”</p><p id="1860427e-38bb-80ea-8609-dd5ef8d322f6" class="">1.2、从 fastbin 中移除每个块并合并，然后放入未排序链表中。这是通过以下两个do  while操作实现的：<div class="indented"><p id="1860427e-38bb-801b-ad46-f0ce1f81f7b4" class="">1.2.1、第一个do while循环用来在fastbinsY数组里面遍历各个fastbin链表</p><p id="1860427e-38bb-804b-946d-f03fa5aaec1f" class="">1.2.2、第二个do while循环用来在一条fastbin链表中遍历每一个fastchunk，其中：<div class="indented"><p id="1860427e-38bb-80e9-bb23-de7bac2d40e1" class="">1.2.2.1、先做一些预处理：找到了当前chunk的size；找到了物理相邻下一个chunk及其size；</p><p id="1860427e-38bb-8022-8d2d-f1e876152fa3" class="">1.2.2.2、向前合并尝试：如果当前块的P位=0，则将当前块与前面块合并后，将前面块从其所在链表中删除</p><p id="1860427e-38bb-80d8-a022-e2abf4558006" class="">1.2.2.3、向后合并尝试，如下：<div class="indented"><p id="1860427e-38bb-80f7-8593-c60a8eb2e87a" class="">（1）如果nextchunk是topchunk，则将当前块融合入topchunk</p><p id="1860427e-38bb-805f-b2b5-e60688ed7e14" class="">（2）如果nextchunk并非topchunk，则检查其是否可用。如果可用，则合并之并将其从链表中删除；否则，清除nextchunk的P标志位。这样处理后的结果，再去设置相关标记位，然后加入unsortedbin</p></div></p></div></p></div></p></div></p><p id="1860427e-38bb-8074-9816-faefe3caf43a" class="">2、如果max_fast==0，则调用malloc_init_state函数初始化av</p></div></p><p id="35b700f2-3c2a-494e-a48b-1caac5f75a87" class=""><mark class="highlight-default"><strong>【代码】</strong></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="30a9dbc4-6d59-419a-ab76-17f7b707068d" class="code"><code class="language-Plain Text">// malloc_consolidate函数内容：
// 如果max_fast!=0，合并空闲块并放入未排序链表；
// 否则，调用malloc_init_state进行malloc_state的初始化
static void malloc_consolidate(mstate av) {
    mfastbinptr* fb;                 /* 当前正在合并的 fastbin */
    mfastbinptr* maxfb;              /* 最后一个 fastbin (用于循环控制) */
    mchunkptr p;                     /* 当前正在合并的块 */
    mchunkptr nextp;                 /* 下一个待合并的块 */
    mchunkptr unsorted_bin;          /* 未排序链表头部 */
    mchunkptr first_unsorted;        /* 待连接的块 */

    /* 下面这些变量与 free() 中的用法相同 */
    mchunkptr nextchunk;
    INTERNAL_SIZE_T size;
    INTERNAL_SIZE_T nextsize;
    INTERNAL_SIZE_T prevsize;
    int nextinuse;
    mchunkptr bck;
    mchunkptr fwd;

    // 1、如果max_fast!=0，则合并空闲块并放入未排序链表；
    if (get_max_fast() != 0) {
		    // 1.1、修改malloc_state的fastchunk标志位为“否”
        clear_fastchunks(av);   
            
        unsorted_bin = unsorted_chunks(av);  /* 获取unsorted bin链表头部地址 */

        // 1.2、从 fastbin 中移除每个块并合并，然后放入未排序链表中。
        // 1.2.1、第一个do while循环用来在fastbinsY数组里面遍历各个fastbin链表
        // 这里，maxfb指向最后一个fastbin（快速二进制块），而fb从第一个fastbin开始。这是因为第一个do while循环的条件是(fb++ != maxfb)，表示用来在fastbinsY数组里面遍历各个fastbin链表
        maxfb = &amp;fastbin(av, NFASTBINS - 1);
        fb = &amp;fastbin(av, 0);
        do {
		        // 这是一个原子操作，用于安全地从fastbin链表中删除并返回第一个块
            p = atomic_exchange_acq(fb, 0); 
            // p!=0也就是“该fastbin存在块”，进入第二个do while循环
            if (p != 0) {
		            // 1.2.2、第二个do while循环用来在一条fastbin链表中遍历每一个fastchunk
                do {
                    check_inuse_chunk(av, p);  /* 检查块是否被正确使用 */
                    nextp = p-&gt;fd;

										// 1.2.2.1、这里做一些预处理：找到了当前chunk的size；找到了物理相邻下一个chunk及其size；
                    /* 这里稍微简化了在 free() 中的合并代码 */
                    size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);
                    nextchunk = chunk_at_offset(p, size);
                    nextsize = chunksize(nextchunk);

										// 1.2.2.2、向前合并尝试
										// 如果当前块的P位=0，则将当前块与前面块合并后，将前面块从其所在链表中删除
                    if (!prev_inuse(p)) {
                        prevsize = p-&gt;prev_size;
                        size += prevsize;
                        p = chunk_at_offset(p, -((long)prevsize));
                        unlink(av, p, bck, fwd);  /* 从链表中移除块 */
                    }
										
										// 1.2.2.3、向后合并尝试
										// （1）如果nextchunk是topchunk，则将当前块融合入topchunk
										// （2）如果nextchunk并非topchunk，则检查其是否可用。如果可用，则合并之并将其从链表中删除；否则，清除nextchunk的P标志位。
                    //     这样处理后的结果，再去设置相关标记位，然后加入unsortedbin
                    if (nextchunk != av-&gt;top) {
                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);

                        if (!nextinuse) {
                            size += nextsize;
                            unlink(av, nextchunk, bck, fwd);  /* 从链表中移除下一个块 */
                        } else
                            clear_inuse_bit_at_offset(nextchunk, 0);

                        first_unsorted = unsorted_bin-&gt;fd;
                        unsorted_bin-&gt;fd = p;
                        first_unsorted-&gt;bk = p;

                        if (!in_smallbin_range(size)) {
                            p-&gt;fd_nextsize = NULL;
                            p-&gt;bk_nextsize = NULL;
                        }

                        set_head(p, size | PREV_INUSE);
                        p-&gt;bk = unsorted_bin;
                        p-&gt;fd = first_unsorted;
                        set_foot(p, size);
                    } else {
                        size += nextsize;
                        set_head(p, size | PREV_INUSE);
                        av-&gt;top = p;
                    }
                } while ((p = nextp) != 0);
            }
        } while (fb++ != maxfb);
     } 
     // 2、如果max_fast==0，则调用malloc_init_state函数初始化av
     else {
        malloc_init_state(av);
        check_malloc_state(av);
     }
}
</code></pre><ul id="32e36b16-edea-4e7b-8bb7-3e402130964b" class="toggle"><li><details open=""><summary>其中，malloc_init_state函数、do_check_malloc_state函数如下</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b8026268-db15-4232-a049-6a0f1a708357" class="code"><code class="language-Plain Text">static void malloc_init_state (mstate av)
{
  int i;
  mbinptr bin;

  // 1、使bin数组里面的各个元素在开始时循环自指
  for (i = 1; i &lt; NBINS; ++i)
    {
      bin = bin_at (av, i);
      bin-&gt;fd = bin-&gt;bk = bin;
    }

#if MORECORE_CONTIGUOUS
  if (av != &amp;main_arena)
#endif
	// 2、初始化一些标志位
	// 初始化MORECORE_CONTIGUOUS
  set_noncontiguous (av);
  // 设置max_fast
  if (av == &amp;main_arena)
    set_max_fast (DEFAULT_MXFAST);
  // 初始化FASTCHUNKS_BIT标志位
  av-&gt;flags |= FASTCHUNKS_BIT;

	// 3、初始化top域，使之指向bin[1]
  // 相关宏定义如下：
	// #define initial_top(M)              (unsorted_chunks (M))
  // #define unsorted_chunks(M)          (bin_at (M, 1))
  av-&gt;top = initial_top (av);
}



static void
do_check_malloc_state (mstate av)
{
  int i;
  mchunkptr p;
  mchunkptr q;
  mbinptr b;
  unsigned int idx;
  INTERNAL_SIZE_T size;
  unsigned long total = 0;
  int max_fast_bin;

  // 断言：内部大小类型size_t&lt;=指针大小（一般来说是==关系）
  assert (sizeof (INTERNAL_SIZE_T) &lt;= sizeof (char *));

  // 断言：对齐是2的幂
  assert ((MALLOC_ALIGNMENT &amp; (MALLOC_ALIGNMENT - 1)) == 0);

  // 在内存分配器未完全初始化之前，不能执行剩余的检查，其中：
  // 当 av-&gt;top == 0 时，表示分配器尚未完成初始化，还没有准备好进行内存分配，因此没有意义去运行进一步的检查。
  // 当 av-&gt;top == initial_top(av) 时，意味着分配器可能刚初始化完成，或者还未经过任何实际的内存分配操作，此时堆的状态被认为是初始状态，不满足进行更深层次一致性检查的前提条件。
  if (av-&gt;top == 0 || av-&gt;top == initial_top (av))
    return;

  //断言：页大小是2的幂
  assert (powerof2(GLRO (dl_pagesize)));

  // 如果是主区域且连续，则验证sbrk基址（也就是系统调用申请的地址的基址）与堆顶部地址是否一致
  if (av == &amp;main_arena &amp;&amp; contiguous (av))
    assert ((char *) mp_.sbrk_base + av-&gt;system_mem ==
            (char *) av-&gt;top + chunksize (av-&gt;top));

  /* properties of fastbins */

  // 断言：global_max_fast在合适的范围内（即&lt;=MAX_FAST_SIZE）
  assert ((get_max_fast () &amp; ~1) &lt;= request2size (MAX_FAST_SIZE));

  max_fast_bin = fastbin_index (get_max_fast ());

	// 遍历所有fastchunk，检查其合法性
  for (i = 0; i &lt; NFASTBINS; ++i)
    {
      p = fastbin (av, i);

      /* The following test can only be performed for the main arena.
         While mallopt calls malloc_consolidate to get rid of all fast
         bins (especially those larger than the new maximum) this does
         only happen for the main arena.  Trying to do this for any
         other arena would mean those arenas have to be locked and
         malloc_consolidate be called for them.  This is excessive.  And
         even if this is acceptable to somebody it still cannot solve
         the problem completely since if the arena is locked a
         concurrent malloc call might create a new arena which then
         could use the newly invalid fast bins.  */

      /* all bins past max_fast are empty */
      if (av == &amp;main_arena &amp;&amp; i &gt; max_fast_bin)
        assert (p == 0);

      while (p != 0)
        {
          /* each chunk claims to be inuse */
          do_check_inuse_chunk (av, p);
          total += chunksize (p);
          /* chunk belongs in this bin */
          assert (fastbin_index (chunksize (p)) == i);
          p = p-&gt;fd;
        }
    }

  if (total != 0)
    assert (have_fastchunks (av));
  else if (!have_fastchunks (av))
    assert (total == 0);

  // 遍历当前堆NBINS里面的所有空闲块，检查其合法性
  for (i = 1; i &lt; NBINS; ++i)
    {
      b = bin_at (av, i);

      /* binmap is accurate (except for bin 1 == unsorted_chunks) */
      if (i &gt;= 2)
        {
          unsigned int binbit = get_binmap (av, i);
          int empty = last (b) == b;
          if (!binbit)
            assert (empty);
          else if (!empty)
            assert (binbit);
        }

      for (p = last (b); p != b; p = p-&gt;bk)
        {
          /* each chunk claims to be free */
          do_check_free_chunk (av, p);
          size = chunksize (p);
          total += size;
          if (i &gt;= 2)
            {
              /* chunk belongs in bin */
              idx = bin_index (size);
              assert (idx == i);
              /* lists are sorted */
              assert (p-&gt;bk == b ||
                      (unsigned long) chunksize (p-&gt;bk) &gt;= (unsigned long) chunksize (p));

              if (!in_smallbin_range (size))
                {
                  if (p-&gt;fd_nextsize != NULL)
                    {
                      if (p-&gt;fd_nextsize == p)
                        assert (p-&gt;bk_nextsize == p);
                      else
                        {
                          if (p-&gt;fd_nextsize == first (b))
                            assert (chunksize (p) &lt; chunksize (p-&gt;fd_nextsize));
                          else
                            assert (chunksize (p) &gt; chunksize (p-&gt;fd_nextsize));

                          if (p == first (b))
                            assert (chunksize (p) &gt; chunksize (p-&gt;bk_nextsize));
                          else
                            assert (chunksize (p) &lt; chunksize (p-&gt;bk_nextsize));
                        }
                    }
                  else
                    assert (p-&gt;bk_nextsize == NULL);
                }
            }
          else if (!in_smallbin_range (size))
            assert (p-&gt;fd_nextsize == NULL &amp;&amp; p-&gt;bk_nextsize == NULL);
          /* chunk is followed by a legal chain of inuse chunks */
          for (q = next_chunk (p);
               (q != av-&gt;top &amp;&amp; inuse (q) &amp;&amp;
                (unsigned long) (chunksize (q)) &gt;= MINSIZE);
               q = next_chunk (q))
            do_check_inuse_chunk (av, q);
        }
    }

  // 检查topchunk是否正常
  check_chunk (av, av-&gt;top);
}
#endif
</code></pre></details></li></ul></details></li></ul><ul id="146c1bfc-f86d-41e1-80d8-1d2441053709" class="toggle"><li><details open=""><summary>sysmalloc函数用于扩大topchunk，详情如下：</summary><p id="83486175-bd10-437a-baa4-027c19d13213" class="">【介绍】</p><p id="6d23eae4-46d4-465c-9eda-a08d870ee5a0" class="">下面是函数的执行逻辑：</p><ol type="1" id="e111ab50-1163-4697-9b16-a49fca68edbe" class="numbered-list" start="1"><li>首先，函数检查是否可以通过 mmap 直接映射请求大小的内存区域，而不是扩展当前的 top。如果满足一定条件，会尝试直接使用 mmap 来满足分配请求。</li></ol><ol type="1" id="bb776551-18e0-44f1-b3c4-ae881d2f7844" class="numbered-list" start="2"><li>如果无法通过 mmap 来满足分配请求，或者需要通过 mmap 来满足但尝试失败，则会尝试使用 sbrk 或者更大单位的 mmap。</li></ol><ol type="1" id="0541cf30-5eeb-49d3-83a4-69ecc01654db" class="numbered-list" start="3"><li>如果当前的 arena 不是主 arena（main_arena），则会尝试扩展当前的堆（heap）或者创建新的堆来满足分配请求。</li></ol><ol type="1" id="44168280-b59a-45d5-bbda-4c23f2d52f32" class="numbered-list" start="4"><li>如果当前的 arena 是主 arena（main_arena），则会尝试通过 sbrk 来扩展堆，并根据需要使用 mmap 来补充。在这个过程中，会对 sbrk 返回的内存进行调整，保证对齐等要求。<blockquote id="c57b219d-91f3-465e-bacf-dd7cf7d48549" class=""><mark class="highlight-blue">这里其实是会新创建一个topchunk，然后把原来不够用的topchunk变成unsorted chunk！</mark><p id="daebcd21-99c4-4de1-a190-0b90d11b59c2" class="">由此我们也会有一个攻击方式“house of orange”</p></blockquote></li></ol><ol type="1" id="9e6773d1-9346-4cd5-ad46-91a9bd13b257" class="numbered-list" start="5"><li>最后，如果有足够的内存满足分配请求，会进行分配操作，并更新 top 指针；如果分配失败，则设置错误码并返回 0。</li></ol><p id="626c673b-caf3-47ef-b281-5e20ba0ac6fb" class="">【源码】</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="35f2fe10-ff51-4f16-85ab-c4fca011d8ac" class="code"><code class="language-C">static void *sysmalloc(INTERNAL_SIZE_T nb, mstate av) {
  mchunkptr old_top;              /* av-&gt;top 的原始值 */
  INTERNAL_SIZE_T old_size;       /* av-&gt;top 的大小 */
  char *old_end;                  /* av-&gt;top 的结束地址 */

  long size;                      /* 传递给第一个 MORECORE 或 mmap 调用的参数 */
  char *brk;                      /* MORECORE 的返回值 */

  long correction;                /* 第二个 MORECORE 调用的参数 */
  char *snd_brk;                  /* 第二个返回值 */

  INTERNAL_SIZE_T front_misalign; /* 新空间前端无法使用的字节 */
  INTERNAL_SIZE_T end_misalign;   /* 新空间末端剩余的部分页 */
  char *aligned_brk;              /* 对齐的 brk 偏移量 */

  mchunkptr p;                    /* 分配/返回的块 */
  mchunkptr remainder;            /* 分配后的剩余块 */
  unsigned long remainder_size;   /* 剩余块的大小 */

  size_t pagesize = GLRO(dl_pagesize); /* 获取系统页大小 */
  bool tried_mmap = false;        /* 是否尝试过 mmap */

  /*
     如果有 mmap，且请求大小达到 mmap 阈值，且系统支持 mmap，
     且当前分配的 mmap 区域数量不多，尝试直接映射请求，而不是扩展 top。
   */
  if (av == NULL ||
      ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp;
       (mp_.n_mmaps &lt; mp_.n_mmaps_max))) {
    char *mm;                     /* mmap 调用的返回值 */

  try_mmap:
    /*
       将大小向上舍入到最近的页。对于 mmapped 块，开销比普通块大一个 SIZE_SZ 单位，
       因为没有后续块可以使用其 prev_size 字段。

       请参见下面的 front_misalign 处理，对于 glibc，除非有高对齐要求，否则无需进一步对齐。
     */
    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
      size = ALIGN_UP(nb + SIZE_SZ, pagesize);
    else
      size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);
    tried_mmap = true;

    /* 如果大小不会溢出为 0，则尝试映射 */
    if ((unsigned long)(size) &gt; (unsigned long)(nb)) {
      mm = (char *)(MMAP(0, size, PROT_READ | PROT_WRITE, 0));

      if (mm != MAP_FAILED) {
        /*
           映射区域的起始偏移量存储在块的 prev_size 字段中。
           这使得我们可以在这里和 memalign() 中调整返回的起始地址以满足对齐要求，
           并且仍然能够在 free() 和 realloc() 中计算正确的地址参数来进行后续的 munmap。
         */

        if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) {
          /* 对于 glibc，chunk2mem 将地址增加了 2*SIZE_SZ，
             MALLOC_ALIGN_MASK 是 2*SIZE_SZ-1。每个 mmap 区域都是页面对齐的，
             因此绝对是 MALLOC_ALIGN_MASK 对齐的。 */
          assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == 0);
          front_misalign = 0;
        } else
          front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;
        if (front_misalign &gt; 0) {
          correction = MALLOC_ALIGNMENT - front_misalign;
          p = (mchunkptr)(mm + correction);
          p-&gt;prev_size = correction;
          set_head(p, (size - correction) | IS_MMAPPED);
        } else {
          p = (mchunkptr)mm;
          set_head(p, size | IS_MMAPPED);
        }

        /* 更新统计信息 */
        int new = atomic_exchange_and_add(&amp;mp_.n_mmaps, 1) + 1;
        atomic_max(&amp;mp_.max_n_mmaps, new);

        unsigned long sum;
        sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;
        atomic_max(&amp;mp_.max_mmapped_mem, sum);

        check_chunk(av, p);

        return chunk2mem(p);
      }
    }
  }

	/* 所有可用的分配区域和 mmap 都失败了。 */
	if (av == NULL)
	  return 0;

	/* 记录 av-&gt;top 的当前配置 */
	old_top = av-&gt;top;
	old_size = chunksize(old_top);
	old_end = (char *)(chunk_at_offset(old_top, old_size));

	brk = snd_brk = (char *)(MORECORE_FAILURE);

	/*
	   如果不是第一次执行，则要求 old_size 至少为 MINSIZE，并且设置了 prev_inuse。
	 */
	assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||
	       ((unsigned long)(old_size) &gt;= MINSIZE &amp;&amp;
	        prev_inuse(old_top) &amp;&amp;
	        ((unsigned long)old_end &amp; (pagesize - 1)) == 0));

	/* 前提条件：当前空间不足以满足 nb 请求 */
	assert((unsigned long)(old_size) &lt; (unsigned long)(nb + MINSIZE));
	
	if (av != &amp;main_arena) {
	    heap_info *old_heap, *heap;
	    size_t old_heap_size;

	    /* 首先尝试扩展当前堆。 */
	    old_heap = heap_for_ptr(old_top);
	    old_heap_size = old_heap-&gt;size;
	    if ((long)(MINSIZE + nb - old_size) &gt; 0 &amp;&amp;
	        grow_heap(old_heap, MINSIZE + nb - old_size) == 0) {
	        av-&gt;system_mem += old_heap-&gt;size - old_heap_size;
	        arena_mem += old_heap-&gt;size - old_heap_size;
	        set_head(old_top, (((char *)old_heap + old_heap-&gt;size) - (char *)old_top) | PREV_INUSE);
	    }
	    else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) {
	        /* 使用新分配的堆。 */
	        heap-&gt;ar_ptr = av;
	        heap-&gt;prev = old_heap;
	        av-&gt;system_mem += heap-&gt;size;
	        arena_mem += heap-&gt;size;
	        /* 设置新的 top。 */
	        top(av) = chunk_at_offset(heap, sizeof(*heap));
	        set_head(top(av), (heap-&gt;size - sizeof(*heap)) | PREV_INUSE);
	
	        /* 设置栅栏并释放旧的 top 块，其大小为 MALLOC_ALIGNMENT 的倍数。 */
	        /* 栅栏至少占用 MINSIZE 字节，因为它可能稍后再次成为顶部块。
	           请注意，尽管标记了使用，但还设置了页脚。 */
	        old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;
	        set_head(chunk_at_offset(old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE);
	        if (old_size &gt;= MINSIZE) {
	            set_head(chunk_at_offset(old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);
	            set_foot(chunk_at_offset(old_top, old_size), (2 * SIZE_SZ));
	            set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);
	            _int_free(av, old_top, 1);
	        }
		      else {
	            set_head(old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);
	            set_foot(old_top, (old_size + 2 * SIZE_SZ));
	        }
	    }
	    else if (!tried_mmap)
			    /* 我们至少可以尝试使用 mmap 内存。 */
		      goto try_mmap;
	}
	else{ /* av == main_arena */
			/* 请求足够的空间以容纳 nb + pad + overhead */

		  size = nb + mp_.top_pad + MINSIZE;

		  /*
		     如果是连续的，我们可以减去现有的空间，希望与新空间结合。
		     仅当我们实际上没有获得连续空间时，我们稍后才将其添加回去。
		   */
		  if (contiguous(av))
		  size -= old_size;

		  /*
		     舍入为页面大小的倍数。
		     如果 MORECORE 不是连续的，则确保我们只以整页参数调用它。
		     如果 MORECORE 是连续的，并且这不是第一次调用，那么这会保留前次调用的页对齐。
		     否则，我们将在下面进行页对齐修正。
		   */
		  size = ALIGN_UP(size, pagesize);

		  /*
		     如果参数太大，以至于看起来为负数，则不要尝试调用 MORECORE。
		     请注意，由于 mmap 接受 size_t 参数，即使我们无法调用 MORECORE，
		     在下面的 mmap 可能也会成功。
		   */
		  if (size &gt; 0){
		      brk = (char *)(MORECORE(size));
		      LIBC_PROBE(memory_sbrk_more, 2, brk, size);
		  }

		  if (brk != (char *)(MORECORE_FAILURE)){
		      /* 如果有必要，则调用“morecore”挂钩。 */
		      void (*hook)(void) = atomic_forced_read(__after_morecore_hook);
		      if (__builtin_expect(hook != NULL, 0))
		          (*hook)();
		  }else{
		      /*
		         如果有 mmap，则在 MORECORE 失败或无法使用时尝试使用它作为备用。
			       在地址空间中存在“空洞”的系统中值得这样做，
		         因此 sbrk 无法扩展以提供连续空间，但其他地方有空间可用。
		         请注意，我们忽略 mmap 的最大计数和阈值限制，
		         因为空间不会被用作分离的 mmap 区域。
		       */
		
		      /* 无法与旧顶部合并，因此将其大小再加回来 */
		      if (contiguous(av))
			        size = ALIGN_UP(size + old_size, pagesize);

		      /* 如果我们依赖 mmap 作为备用，那么使用更大的单位 */
		      if ((unsigned long)(size) &lt; (unsigned long)(MMAP_AS_MORECORE_SIZE))
				      size = MMAP_AS_MORECORE_SIZE;

		      /* 不要尝试如果 size 超出 0 */
		      if ((unsigned long)(size) &gt; (unsigned long)(nb)){
			        char *mbrk = (char *)(MMAP(0, size, PROT_READ | PROT_WRITE, 0));

		          if (mbrk != MAP_FAILED){
		              /* 我们不需要，也不能使用另一个 sbrk 调用来查找结束 */
		              brk = mbrk;
		              snd_brk = brk + size;

		              /*
		                 记录我们不再拥有连续的 sbrk 区域。
		                 第一次使用 mmap 作为备用后，我们永远不再依赖连续空间，
		                 因为这可能会错误地桥接区域。
		               */
		              set_noncontiguous(av);
		          }
		      }
		  }
	
			if (brk != (char *)(MORECORE_FAILURE)){
			    if (mp_.sbrk_base == 0)
			        mp_.sbrk_base = brk;
		
			    // 增加系统内存统计信息
				  av-&gt;system_mem += size;

			    /*
		       如果 MORECORE 扩展了先前的空间，我们可以同样扩展 top 的大小。
			    */
			    if (brk == old_end &amp;&amp; snd_brk == (char *)(MORECORE_FAILURE))
			        set_head(old_top, (size + old_size) | PREV_INUSE);
	
			    else if (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end){
			        /* 糟糕！有人破坏了我们的空间…不能触及任何东西 */
			        malloc_printerr(3, &quot;break adjusted to free malloc space&quot;, brk, av);
			    }

		    /*
		       否则，做一些调整：
		     * 如果第一次调用或非连续的，我们需要调用 sbrk 仅仅是为了找出内存的末尾位置。
		     * 我们需要确保从 malloc 返回的所有块都满足 MALLOC_ALIGNMENT
		     * 如果有一个间隔的外来 sbrk，我们需要调整 sbrk 请求的大小，
		        以考虑我们将无法将新空间与 old_top 中的现有空间合并。
		     * 几乎所有系统内部一次分配整个页面的内存，在这种情况下，我们可能会
		        用最后一个请求页的整个空间，因此我们现在分配足够的内存以达到页面边界，
		        这反过来又导致将来的连续调用进行页面对齐。
		     */

				  else{
				      front_misalign = 0;
				      end_misalign = 0;
				      correction = 0;
				      aligned_brk = brk;
			
				      /* 处理连续的情况 */
				      if (contiguous(av)){
				          /* 计算外来 sbrk 作为 system_mem。 */
				          if (old_size)
				              av-&gt;system_mem += brk - old_end;
	
				          /* 保证从此空间创建的第一个新块的对齐 */
				          front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;
				          if (front_misalign &gt; 0){
		                /*
		                   跳过一些字节以到达对齐位置。
		                   我们不需要特别标记这些浪费的前置字节。
		                   无论如何，它们永远不会被访问，因为初始化后 av-&gt;top 的
		                   prev_inuse 总是 true（以及从其开头创建的任何块）。
		                 */
				              correction = MALLOC_ALIGNMENT - front_misalign;
				              aligned_brk += correction;
					        }

			            /*
			             如果这不是与现有空间相邻的话，那么我们将无法与 old_top 空间合并，
		               因此必须添加到第二个请求。
			            */
				          correction += old_size;
	
				          /* 将结束地址扩展到达到页面边界 */
				          end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);
				          correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;
	
				          assert(correction &gt;= 0);
				          snd_brk = (char *)(MORECORE(correction));
	
			            /*
		               如果无法分配 correction，尝试至少找出当前的 brk。
		               如果 second sbrk 没有失败，我们假定 space 与 first sbrk 连续。
		               这是一个安全的假设，除非程序是多线程的但不使用锁，而在第一次
		               和第二次调用之间发生了外来的 sbrk。
			             */
				          if (snd_brk == (char *)(MORECORE_FAILURE)){
				               correction = 0;
				               snd_brk = (char *)(MORECORE(0));
				          }else{
				               /* 如果有必要，则调用“morecore”挂钩。 */
				               void (*hook)(void) = atomic_forced_read(__after_morecore_hook);
				               if (__builtin_expect(hook != NULL, 0))
				                   (*hook)();
				          }
				      }

              /* handle non-contiguous cases */
				      else{
				          if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
				              /* MORECORE/mmap must correctly align */
				              assert (((unsigned long) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == 0);
				          else{
				              front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;
				              if (front_misalign &gt; 0){
                          /*
                             Skip over some bytes to arrive at an aligned position.
                             We don&#x27;t need to specially mark these wasted front bytes.
                             They will never be accessed anyway because
                             prev_inuse of av-&gt;top (and any chunk created from its start)
                             is always true after initialization.
                           */

		                  aligned_brk += MALLOC_ALIGNMENT - front_misalign;
				              }
				          }

				          /* Find out current end of memory */
				          if (snd_brk == (char *) (MORECORE_FAILURE)){
				              snd_brk = (char *) (MORECORE (0));
				          }
				      }

              /* Adjust top based on results of second sbrk */
              if (snd_brk != (char *) (MORECORE_FAILURE)){
                  av-&gt;top = (mchunkptr) aligned_brk;
                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
                  av-&gt;system_mem += correction;

                  /*
                     If not the first time through, we either have a
                     gap due to foreign sbrk or a non-contiguous region.  Insert a
                     double fencepost at old_top to prevent consolidation with space
                     we don&#x27;t own. These fenceposts are artificial chunks that are
                     marked as inuse and are in any case too small to use.  We need
                     two to make sizes and alignments work out.
                   */

                  if (old_size != 0){
                      /*
                         Shrink old_top to insert fenceposts, keeping size a
                         multiple of MALLOC_ALIGNMENT. We know there is at least
                         enough space in old_top to do this.
                       */
                      old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;
                      set_head (old_top, old_size | PREV_INUSE);

                      /*
                         Note that the following assignments completely overwrite
                         old_top when old_size was previously MINSIZE.  This is
                         intentional. We need the fencepost, even if old_top otherwise gets
                         lost.
                       */
                      chunk_at_offset (old_top, old_size)-&gt;size =
                        (2 * SIZE_SZ) | PREV_INUSE;

                      chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size =
                        (2 * SIZE_SZ) | PREV_INUSE;

                      /* If possible, release the rest. */
                      if (old_size &gt;= MINSIZE){
                          _int_free (av, old_top, 1);
                      }
                  }
              }
          }
      }
  } /* if (av !=  &amp;main_arena) */

  if ((unsigned long) av-&gt;system_mem &gt; (unsigned long) (av-&gt;max_system_mem))
    av-&gt;max_system_mem = av-&gt;system_mem;
  check_malloc_state (av);

  /* finally, do the allocation */
  p = av-&gt;top;
  size = chunksize (p);

  /* check that one of the above allocation paths succeeded */
  if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)){
      remainder_size = size - nb;
      remainder = chunk_at_offset (p, nb);
      av-&gt;top = remainder;
      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
      set_head (remainder, remainder_size | PREV_INUSE);
      check_malloced_chunk (av, p, nb);
      return chunk2mem (p);
  }

  /* catch all failure paths */
  __set_errno (ENOMEM);
  return 0;
}

							/* 处理非连续的情况 */
							else {
							    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
							        /* MORECORE/mmap 必须确保正确对齐 */
							        assert (((unsigned long) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == 0);
							    else {
							        front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;
							        if (front_misalign &gt; 0) {
							            /* 跳过一些字节以达到对齐位置。
							               不需要特别标记这些被浪费的前端字节。
							               无论如何，它们将不会被访问，因为 av-&gt;top 的 prev_inuse（以及从它开始创建的任何块）
							               在初始化后总是为 true。 */
							            aligned_brk += MALLOC_ALIGNMENT - front_misalign;
							        }
							    }

							    /* 查找当前内存的末尾 */
							    if (snd_brk == (char *) (MORECORE_FAILURE)) {
							        snd_brk = (char *) (MORECORE(0));
							    }
							}

							/* 根据第二次 sbrk 的结果调整 top */
							if (snd_brk != (char *) (MORECORE_FAILURE)) {
							    av-&gt;top = (mchunkptr) aligned_brk;
							    set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
							    av-&gt;system_mem += correction;

							    /* 如果不是第一次通过，我们要么有一个外来 sbrk 导致的间隙，要么是一个非连续的区域。
							       在 old_top 处插入一个双栅栏，防止与我们不拥有的空间合并。
							       这些栅栏是标记为使用中的人工块，无论如何都太小而无法使用。
							       我们需要两个来使大小和对齐正常。 */
							    if (old_size != 0) {
							        /* 收缩 old_top 以插入栅栏，保持大小是 MALLOC_ALIGNMENT 的倍数。
							           我们知道 old_top 中至少有足够的空间来做到这一点。 */
							        old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;
							        set_head(old_top, old_size | PREV_INUSE);

							        /* 请注意，以下分配会在 old_size 之前是 MINSIZE 时完全覆盖 old_top。
							           这是故意的。我们需要栅栏，即使 old_top 否则可能会丢失。 */
							        chunk_at_offset(old_top, old_size)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE;
							        chunk_at_offset(old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE;
			
							        /* 如果可能，释放剩余的部分。 */
							        if (old_size &gt;= MINSIZE) {
							            _int_free(av, old_top, 1);
							        }
							    }
							}
					}
			}
	}

	if ((unsigned long) av-&gt;system_mem &gt; (unsigned long) (av-&gt;max_system_mem))
	    av-&gt;max_system_mem = av-&gt;system_mem;

	check_malloc_state(av);
	
	/* 最后，进行分配 */
	p = av-&gt;top;
	size = chunksize(p);
	
	/* 检查上述分配路径之一是否成功 */
	if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {
	    remainder_size = size - nb;
	    remainder = chunk_at_offset(p, nb);
	    av-&gt;top = remainder;
	    set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
	    set_head(remainder, remainder_size | PREV_INUSE);
	    check_malloced_chunk(av, p, nb);
	    return chunk2mem(p);
	}

	/* 捕获所有失败路径 */
	__set_errno(ENOMEM);
	return 0;
}
</code></pre></details></li></ul><h1 id="dedaeb86-0d72-4a78-9c4e-035533a7ca80" class="block-color-default_background">三、free函数执行流程</h1><h3 id="200dfa13-e10c-432d-8801-488f9f7b315a" class=""><strong>1-过程简介</strong></h3><ul id="17c0427e-38bb-8065-855d-ffe70b800c14" class="toggle"><li><details open=""><summary>1、<strong>一些预处理</strong></summary><p id="17c0427e-38bb-80e7-91e0-f3ce7b797201" class="">（1）在libc_free函数中，做钩子处理，并检查用户输入的指针不应为NULL，</p><p id="17c0427e-38bb-8082-bb80-c1bcf7eff88d" class="">（2）如果用户输入的块是通过mmap分配的，则直接释放之；否则，调用int_free函数</p><p id="17c0427e-38bb-80b7-9050-fb89c779e496" class="">（3）</p></details></li></ul><ul id="17d0427e-38bb-806b-b909-c673785b6809" class="toggle"><li><details open=""><summary>2、<strong>通用安全检查</strong></summary><p id="1800427e-38bb-8061-9243-fd8032648429" class="">（1）一些针对传参指针p的安全性检查<div class="indented"><p id="1800427e-38bb-8098-b641-ebbcca540383" class="">{1} p指向的方向是否超出了用户内存区域</p><p id="1800427e-38bb-8055-861e-e5778e9ee7d1" class="">{2} p的起始地址是否已按要求对齐</p></div></p><p id="1800427e-38bb-80b7-b5c6-c784673a3ce8" class="">（2）一些针对传参大小size的安全性检查<div class="indented"><p id="1800427e-38bb-80c0-9bd4-e381d8bd03d4" class="">{1} 当前块大小是否大于MINSIZE</p><p id="1800427e-38bb-80a3-a374-db6beeb03272" class="">{3} 当前块大小是否符合对齐要求</p></div></p><p id="1800427e-38bb-806b-b9ee-ec7585a4fa38" class="">（3）针对double free的安全性检查：调用do_check_inuse_chunk函数，其中最主要的是查看下一个chunk的P是否==1</p></details></li></ul><ul id="17d0427e-38bb-80c0-981f-e7c3c4631dda" class="toggle"><li><details open=""><summary>3、如果size≤global_max_fast，<strong>将其视为fastbin回收</strong></summary><blockquote id="1800427e-38bb-8097-975b-de0fb35b0311" class="">注意：如果TRIM_FASTBINS被设置，且该块与topchunk相邻，则不将其放入“快速分配链表”中。</blockquote><p id="1800427e-38bb-8083-8b9f-d8a196d98f0a" class="">（1）安全检查，不满足则报错：<div class="indented"><p id="1800427e-38bb-804f-91ab-fd878d2cecbd" class="">{1} 物理相邻下一个内存块的大小是否&lt;=2 * SIZE_SZ，这是为了防止攻击者堆溢出修改下一个chunk的size字段</p><p id="1800427e-38bb-8036-93a5-d7cec48c4515" class="">{2} 当前chunnk的size是否&gt;=av-&gt;system_mem，system_mem是系统分配的最大内存块大小，这是为了防止houseOfForce攻击</p></div></p><p id="1800427e-38bb-80a4-bdf9-fe2ec8b936f1" class="">（2）&#x27;\0&#x27;填充清空当前chunk的data域的内容！</p><p id="1800427e-38bb-8045-9af8-e1a7fed831fb" class="">（3）一处针对doublefree的安全检查：检查链表顶部是否正好也是我们要free的这个chunk，如果是则报错</p><p id="1800427e-38bb-806a-9676-d49617ef7928" class="">（4）原子地将P链接到其对应fastbin开始处: P-&gt;FD = *FB; *FB = P;</p><p id="1800427e-38bb-8003-b705-e784dc5cf357" class="">（5）安全检查：检查顶部快速分配块的大小是否与要添加的块的大小相同</p></details></li></ul><ul id="17d0427e-38bb-80bd-9405-e87156402931" class="toggle"><li><details open=""><summary>4、否则，<strong>将其视为非fastchunk回收</strong></summary><p id="1800427e-38bb-80cd-b0c7-c030eb87a985" class="">（1）专用于非fastchunk回收的安全检查：<div class="indented"><p id="1800427e-38bb-80b3-bdc6-f5b5a9af66f9" class="">安全检查1-再次检查它是否为mmap产生的chunk（之前在__libc_free里曾经检查过一次）<br/>安全性检查-2：检查当前块是否为topchunk，是则报错<br/>安全性检查-3：检查下一个块是否超出了arena的边界<br/>安全性检查-4：检查当前chunk是否已经被free过，防止doublefree<br/>安全性检查-5：检查当前chunk的下一个chunk的大小是否合法（&gt;2个指针大小，小于av-&gt;system_mem提示的能分配的内存最大<br/></p></div></p><p id="1800427e-38bb-8032-a476-ea6ff90a7642" class="">（2）&#x27;\0&#x27;填充清空当前chunk的data域的内容！</p><p id="1800427e-38bb-8052-b0bd-dfd1e0ce8f89" class="">（3）chunk前后合并机制！<div class="indented"><p id="1800427e-38bb-80a0-94b7-f6ad53f1df45" class="">{1} 向前合并尝试</p><p id="1800427e-38bb-80a1-9705-c01947e4b878" class="">{2} 向后合并尝试，分为两种可能：</p><p id="1800427e-38bb-80bb-9a28-df9567525f15" class="">如果后面chunk不是topchunk ，则：<div class="indented"><p id="1800427e-38bb-8030-a0a3-dcb929e81e3c" class="">① 将后一个chunk合并入当前chunk中</p><p id="1800427e-38bb-8063-9038-d8b52904d7a1" class="">② 安全性检查：要求必须满足fwd-&gt;bk = bck-&gt;fd否则报错</p><p id="1800427e-38bb-8015-8004-ec30dabe8c47" class="">③ 将块放入unsorted bin中</p><p id="1800427e-38bb-8092-8d9b-ff9cc66e8853" class="">④如果是large_bin大小，则会把它用到的fd_nextsize、bk_nextsize做一个初始化</p><p id="1800427e-38bb-8023-b5d1-e76ce3b39ab7" class="">⑤设置当前chunk的相关标志位</p></div></p><p id="1800427e-38bb-801b-b118-f08ad26e9972" class="">如果后面chunk是topchunk ，则：<div class="indented"><p id="1800427e-38bb-80d9-a3db-eca4c871e106" class="">将当前chunk合并入topchunk中，设置topchunk标志位，调用check_chunk进行安全检查</p></div></p></div></p></details></li></ul><h3 id="3183f3ef-50f4-4bab-b35d-0fc36d13b14b" class=""><strong>2-示意图</strong></h3><ul id="17c0427e-38bb-809a-966c-fd84b9af9a80" class="toggle"><li><details open=""><summary>以x32环境下的free函数为例</summary><figure id="45470238-d5a2-4519-ba22-62c69268ec38" class="image" style="text-align:left"><a href="ptmalloc2%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%2042d57ad04c9544898cfa507d4d47dde4/Untitled%202.png"><img style="width:384px" src="ptmalloc2%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%2042d57ad04c9544898cfa507d4d47dde4/Untitled%202.png"/></a></figure><figure id="5a8c2c19-5ed6-4909-8a81-c9f7d9d10132" class="image" style="text-align:left"><a href="ptmalloc2%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%2042d57ad04c9544898cfa507d4d47dde4/Untitled%203.png"><img style="width:480px" src="ptmalloc2%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%2042d57ad04c9544898cfa507d4d47dde4/Untitled%203.png"/></a></figure></details></li></ul><p id="1750427e-38bb-8016-b944-fe24d66aaa1d" class=""><mark class="highlight-red"><mark class="highlight-red_background">要改</mark></mark></p><h3 id="06e5feff-c63a-486c-9963-8c0d22126078" class="">3-源码解析</h3><blockquote id="1770427e-38bb-809b-a42d-c0212f1c3701" class="">源码出处：<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></blockquote><p id="1770427e-38bb-80a3-a3da-f2b45503744c" class="">先是进到__libc_free函数，然后该函数调用_int_free函数来完成主要的块释放过程</p><ul id="17b0427e-38bb-8096-8ce5-e097e7d44b95" class="toggle"><li><details open=""><summary><strong>__libc_free函数代码如下：</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17b0427e-38bb-8027-a62f-d00e79672754" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">void __libc_free (void *mem) // 参数 mem 指向要释放的内存块的地址。
{
  mstate ar_ptr; // 用于表示当前线程使用的内存区域（arena）的状态。
  mchunkptr p;                          /* chunk 对应于 mem 的内存块 */

	// 1、钩子处理
  // 获取全局 free 钩子函数。这个钩子允许用户在实际释放发生之前插入自定义逻辑。
  void (*hook) (void *, const void *) = atomic_forced_read (__free_hook);
  // 如果有设置 free 钩子并且它不是一个空指针，则调用该钩子进行内存释放。
  if (__builtin_expect (hook != NULL, 0)) // __builtin_expect 优化分支预测，期望通常情况下 hook 是 NULL。
    {
      (*hook)(mem, RETURN_ADDRESS (0)); // 调用用户定义的 hook 函数，并传递要释放的内存地址和返回地址。
      return; // 直接退出，不再执行下面的标准释放逻辑。
    }

	// 2、针对用户输入的安全检查
  // 如果传入的指针为 NULL，则 free(0) 不应该有任何效果，直接返回。
  if (mem == 0)                            
    return;
    
  // 将用户提供的内存指针转换为对应的 chunk 结构。
  p = mem2chunk (mem);
  
  // 3、如果用户输入的块是通过mmap分配的，则直接释放
  // 检查该 chunk 是否是通过 mmap 分配的内存。
  if (chunk_is_mmapped (p))                       /* release mmapped memory. */
    {
      /* 
       * 如果不是禁用动态调整阈值，并且该 chunk 的大小大于当前的 mmap 阈值，
       * 但不超过默认的最大 mmap 阈值，则调整 mmap 和 trim 的阈值。
       */
      if (!mp_.no_dyn_threshold
          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold
          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)
        {
          // 更新 mmap 和 trim 的阈值为当前 chunk 的大小。
          mp_.mmap_threshold = chunksize (p);
          mp_.trim_threshold = 2 * mp_.mmap_threshold;
          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, // 发出调试信息，表明正在调整动态阈值。
                      mp_.mmap_threshold, mp_.trim_threshold);
        }
      // 释放通过 mmap 分配的内存。
      munmap_chunk (p);
      return;
    }

	// 4、否则，通过_int_free函数释放值之
  // 根据 chunk 找到所属的 arena。
  ar_ptr = arena_for_chunk (p);
  // 使用 _int_free 函数来释放 arena 中的内存块。
  _int_free (ar_ptr, p, 0); // 第三个参数通常用于标志位，这里设为 0 表示普通释放。
}</code></pre></details></li></ul><ul id="1770427e-38bb-8067-bdbf-ef854a432e3c" class="toggle"><li><details open=""><summary><strong>_int_free函数代码如下：</strong></summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0de1ad9d-5d06-408f-8daa-c9b504292113" class="code"><code class="language-Plain Text">static void _int_free(mstate av, mchunkptr p, int have_lock)   //传参：av是“存储堆管理信息的结构体”，p是要free掉的那块chunk，lock是锁的状态
{
  INTERNAL_SIZE_T size;     /* 要free的块的大小 */
  mfastbinptr *fb;          /* 相关的快速分配链表 */
  mchunkptr nextchunk;      /* 下一个相邻的块 */
  INTERNAL_SIZE_T nextsize; /* 下一个块的大小 */
  int nextinuse;            /* 下一个块是否被使用 */
  INTERNAL_SIZE_T prevsize; /* 前一个相邻块的大小 */
  mchunkptr bck;            /* 链表操作临时变量 */
  mchunkptr fwd;            /* 链表操作临时变量 */
  const char *errstr = NULL;
  int locked = 0;           /* 互斥锁 */
  size = chunksize (p);

	/********************************************
		通用安全检查！
	*********************************************/
	// 1、通用安全检查-----------------------------------------
	// 1.1、一些针对传参指针p的安全性检查
	// （1）p指向的方向是否超出了用户内存区域；（2）p的起始地址是否已按要求对齐。
  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)  // （1）将p转换成unsigned后，会不会大于将-size转成unsigned int的结果。一般来说-size对应的内存是：0b11111111...，而如果在x32系统下，因为linux设定的用户内存区域是3G，所以指针正常应该不能超过0b11.....。
																															 //      所以，如果p转换成unsigned后&gt;将-size转成unsigned int的结果，则表示p一定是超出了用户内存区域。
      || __builtin_expect (misaligned_chunk (p), 0))           // （2）检查当前要释放的块 p 的块的起始地址是否按照要求对齐
    {
      // 报错
      errstr = &quot;free(): invalid pointer&quot;;
    errout:
      if (!have_lock &amp;&amp; locked)
        (void) mutex_unlock (&amp;av-&gt;mutex);
      malloc_printerr (check_action, errstr, chunk2mem (p), av);
      return;
    }

  // 1.2、一些针对传参大小size的安全性检查
  // （1）当前块大小是否大于MINSIZE； （2）当前块大小是否符合对齐要求。
  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) // （1）检查当前要释放的块 p 的大小是否大于MINSIZE （2）检查当前块的大小是否符合对齐要求
	  {
      errstr = &quot;free(): invalid size&quot;;
      goto errout;
    }
    
  // 1.3、针对double free的安全性检查
  // 调用do_check_inuse_chunk函数，其中最主要的是查看下一个chunk的P是否==1（以防止double free）
  check_inuse_chunk(av, p);       

	/********************************************
		将其视为fastbin回收部分！
	*********************************************/
	// 2、如果它的大小&lt;=get_max_fast，则尝试“将当前chunk放入fastbin链表”------------------------------------------
	if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())
#if TRIM_FASTBINS
    //如果TRIM_FASTBINS被设置，且该块与topchunk相邻，则不将其放入“快速分配链表”中。
    &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)
#endif
    ) {

	  // 2.1、专用于fastchunk回收的安全检查：
	  // （1）物理相邻下一个内存块的大小是否&lt;=2 * SIZE_SZ，如果是就太小了——小于最小chunk大小。
    // （2）当前chunnk的size是否&gt;=av-&gt;system_mem，system_mem是系统分配的最大内存块大小，如果是就太大佬。
 	  // 不满足要求会发生一些报错
    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)
        || __builtin_expect (chunksize (chunk_at_offset (p, size))&gt;= av-&gt;system_mem, 0))
      {
        // 进行一些锁的处理
        // 如果have_lock即当前线程有互斥锁，那就执行报错；否则走到||右边的{}里，去执行上锁的一系列操作，然后再报错
        if (have_lock|| ({ assert (locked == 0);mutex_lock(&amp;av-&gt;mutex);locked = 1;chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ|| chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;}))
         {
	  		  errstr = &quot;free(): invalid next size (fast)&quot;;
	  		  goto errout;
	  		 }
	  		// 如果之前没有锁然后是通过{}里面的语句获得了锁，则在这里通过mutex_unlock释放锁。
        if (! have_lock)
         {
	  		  (void)mutex_unlock(&amp;av-&gt;mutex);
	  		  locked = 0;
		  	 }
	    }

  	// 2.2、&#x27;\0&#x27;填充清空当前chunk的data域的内容！
    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);

    set_fastchunks(av);       // 设置当前malloc_state的快速分配标志位为“是”（表示有fastchunk）
    unsigned int idx = fastbin_index(size); // 根据当前chunk的size获得对应的fastbin的idx
    fb = &amp;fastbin (av, idx);  // 获得fastbinsY[idx]这个数组元素的地址！

    mchunkptr old = *fb, old2;// 变量old指向了fastbin链表里的第一个chunk
    unsigned int old_idx = ~0u;
    do{
	 	    // 2.3、一处针对doublefree的检查
        // 检查fastbin链表里的第一个chunk是否正好也是我们要free的这个chunk，如果是则报错
        if (__builtin_expect (old == p, 0))
         {
			     errstr = &quot;double free or corruption (fasttop)&quot;;
			     goto errout;
			   }
        if (have_lock &amp;&amp; old != NULL)
					 old_idx = fastbin_index(chunksize(old));
			  // 2.4、原子地将P链接到其快速分配链表中: P-&gt;FD = *FB; *FB = P;
        p-&gt;fd = old2 = old;
    }while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);
		//其中，while的操作是一个自旋操作，意义是不断地尝试将该块加入fastbin，似乎是为了应对多线程的
	
	  // 2.5、其中，一处安全性检查：检查顶部快速分配块的大小是否与要添加的块的大小相同
    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))
      {
        errstr = &quot;invalid fastbin entry (free)&quot;;
        goto errout;
      }
  }//到这里，将其放进fastbin的尝试结束

	/********************************************
		将其视为非fastchunk回收部分！
	*********************************************/
// 3、将其视为非fastchunk回收-------------------------------------------------------------------
// 3.1、专用于非fastchunk回收的安全检查：
// 3.1.1、安全检查1-再次检查它是否为mmap产生的chunk（之前在__libc_free里曾经检查过一次）
else if (!chunk_is_mmapped(p)) 
 {
	 //锁相关的处理
   if (! have_lock) 
    {
      (void)mutex_lock(&amp;av-&gt;mutex);
      locked = 1;
    }

	 //获得物理相邻的下一个chunk
   nextchunk = chunk_at_offset(p, size);

   // 3.1.2安全性检查-2：检查当前块是否为topchunk，是则报错
   if (__glibc_unlikely (p == av-&gt;top))
     {
       errstr = &quot;double free or corruption (top)&quot;;
       goto errout;
     }
   // 3.1.3安全性检查-3：检查下一个块是否超出了arena的边界
   if (__builtin_expect (contiguous (av)                                    //若堆的内存是连续的
	    &amp;&amp; (char *) nextchunk&gt;= ((char *) av-&gt;top + chunksize(av-&gt;top))       //则检查“下一个chunk的起始地址”是否&gt;=“topchunk的结尾地址”。
	    , 0)){
        errstr = &quot;double free or corruption (out)&quot;;
        goto errout;
    }
   // 3.1.4安全性检查-4：检查当前chunk是否已经被free过，防止doublefree
   if (__glibc_unlikely (!prev_inuse(nextchunk)))
    {
      errstr = &quot;double free or corruption (!prev)&quot;;
      goto errout;
    }
	 // 3.1.5安全性检查-5：检查当前chunk的下一个chunk的大小是否合法（&gt;2个指针大小，小于av-&gt;system_mem提示的能分配的内存最大大小）
	 //这应该是为了防止攻击者恶意构建当前chunk的物理相邻下一个chunk，但是只检查了size字段还是可以构建的~
   nextsize = chunksize(nextchunk);
   if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)
      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))
    {
      errstr = &quot;free(): invalid next size (normal)&quot;;
      goto errout;
    }

	 // 3.2、&#x27;\0&#x27;填充清空当前chunk的data域的内容！
   free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); 

	 // 3.3、非fastchunk回收时的前后合并机制！
   // 3.3.1、向前合并尝试
   if (!prev_inuse(p))
    {
      prevsize = p-&gt;prev_size;
      size += prevsize;
      p = chunk_at_offset(p, -((long) prevsize)); //让p寻址到前一个chunk，然后unlink
      unlink(av, p, bck, fwd);
    }
	 // 3.3.2、向后合并尝试
	 // 3.3.2.1、如果后面chunk不是topchunk
   if (nextchunk != av-&gt;top)
    {
	    // 3.3.2.1.1、将后一个chunk合并入当前chunk中
      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);//获取下一个chunk的prev_inuse位
      if (!nextinuse) //如果下一个chunk是freechunk则触发合并
       {
         unlink(av, nextchunk, bck, fwd);
         size += nextsize;
       } 
      else           //如果下一个chunk是allocated chunk则不合并，但也会将其prev_inuse标志位设置为0
         clear_inuse_bit_at_offset(nextchunk, 0);

	    // 块只有在给予malloc使用的机会之后，才会放入常规的分配区块中。
	    bck = unsorted_chunks(av);    //#define unsorted_chunks(M) (bin_at (M, 1))，根据宏定义是返回bin[1]这个元素的地址
	    fwd = bck-&gt;fd;
	    
		  // 3.3.2.1.2、安全性检查：要求必须满足fwd-&gt;bk = bck-&gt;fd否则报错
	    //然而这个也是可以绕过滴~
	    if (__glibc_unlikely (fwd-&gt;bk != bck))
	     {
				 errstr = &quot;free(): corrupted unsorted chunks&quot;;
				 goto errout;
	     }
	     
	    // 3.3.2.1.3、将块放入unsorted bin中
	    p-&gt;fd = fwd;
	    p-&gt;bk = bck;    
	    
	    // 3.3.2.1.4、如果是large_bin大小，则会把它用到的fd_nextsize、bk_nextsize做一个初始化
	    if (!in_smallbin_range(size))
	     {
				 p-&gt;fd_nextsize = NULL;
				 p-&gt;bk_nextsize = NULL;
	     }
	    bck-&gt;fd = p;
	    fwd-&gt;bk = p;

			// 3.3.2.1.4、设置当前chunk的相关标志位
	    set_head(p, size | PREV_INUSE);
	    set_foot(p, size);

	    check_free_chunk(av, p); // 检查释放的块
	  }
	  
	 // 3.3.2.2、如果后面chunk是topchunk
	 // 则将当前chunk合并入topchunk中，设置topchunk标志位，调用check_chunk进行安全检查
   //这也包括了前一个被合并入当前chunk的块，在这里也会一起合并入opchunk中
   else 
    {
     size += nextsize;
     set_head(p, size | PREV_INUSE);
     av-&gt;top = p;
     check_chunk(av, p); // 检查块
    }
  }</code></pre></details></li></ul><h1 id="04b5447b-683f-43e0-b5be-844dbb8c87cb" class="block-color-default_background">四、其他相关函数</h1><h3 id="1700427e-38bb-801f-bc1a-f7cea488ffec" class="">1-mallopt函数</h3><p id="95652e72-e934-4f32-80e4-f0162c356e81" class="">【定义】</p><p id="c8345406-4457-42c2-acb8-c96dbc84b955" class="">C标准库中的，用于设置 malloc() 函数的参数</p><p id="3dae3ec0-7c80-4087-bb4f-f93dc746c0c0" class="">【传参】</p><p id="2902d1fc-610b-4d2e-acdb-30e46ba46b1d" class="">第一个是选项，第二个是要给这个选项设置为多少值</p><p id="ac488cd5-fa33-495b-980a-94baf0de9277" class="">【示例】</p><p id="fdd16eb0-8e16-454d-b430-eeb67575efd2" class="">mallopt(1,0)：修改global_max_fast的值为0，并且按照修改后的global_max_fast去把原先在fastbin中的堆拿出来放到unsortedbin中去</p><h3 id="1700427e-38bb-804a-9a2b-f1c881834dee" class="">2-malloc_hook和free_hook函数</h3><p id="1700427e-38bb-80c9-ad01-e6a1e76d32b2" class="">【定义】</p><p id="1700427e-38bb-80f7-b134-e482d12ec609" class="">堆创建删除的时候，执行钩子代码 </p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>